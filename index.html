<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>我的手机</title>
    <style id="custom-font-style"></style>
    <style>
        /* 页面基础样式，用于将手机框居中显示 */
        body {
            background-color: #dfdfdf;
            /* 淡灰色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            font-family: sans-serif;
        }

        /* === 新增：移除移动端点击时的高亮背景 === */
        * {
            -webkit-tap-highlight-color: transparent;
        }

        /* 手机外框 */
        .phone-frame {
            width: 375px;
            /* 模拟iPhone X/11/12/13 Pro的宽度 */
            height: 700px;
            /* 模拟iPhone X/11/12/13 Pro的高度 */
            border: 6px solid #111;
            /* 手机边框颜色 */
            border-radius: 54px;
            /* 圆角边框 */
            background: #d5d4d4;
            /* 屏幕默认背景色 */
            box-shadow: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
            position: relative;
            overflow: hidden;
            /* 隐藏超出屏幕的内容 */
        }

        /* 手机屏幕区域 */
        .screen {
            width: 100%;
            height: 100%;
            background: #fff;
            /* 如果内容超出屏幕高度，允许滚动 */
            position: absolute;
            /* 让两个页面可以重叠 */
            transition: opacity 0.3s ease-in-out;
            /* 动画效果 */
        }



        /* --- 新的淡入淡出动画控制样式 --- */

        /* 默认状态：主屏幕完全不透明，并且可以交互 */
        #home-screen {
            opacity: 1;
            pointer-events: auto;
            /* 允许鼠标点击等交互 */
            z-index: 2;
            /* 在默认状态下，主屏幕在最上层 */
        }

        /* 默认状态：设置页完全透明，并且无法交互 */
        #settings-screen {
            opacity: 0;
            pointer-events: none;
            /* 禁止鼠标点击等交互 */
            z-index: 1;
            /* 在默认状态下，设置页在下层 */
        }

        /* 当 phone-frame 拥有 .show-settings 类名时，反转上面的状态 */
        .phone-frame.show-settings #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 主屏幕沉下去 */
        }

        .phone-frame.show-settings #settings-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 设置页浮上来 */
        }

        /* === 新增：音乐App的动画控制 === */
        /* 默认状态：音乐页完全透明，并且无法交互 */
        #music-screen {
            display: flex;
            flex-direction: column;
            /* 垂直排列 */
            height: 100%;
            /* 确保它占满父容器的高度 */
            overflow: hidden;
            /* 防止整个屏幕意外滚动 */
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* 当 phone-frame 拥有 .show-music 类名时 */
        .phone-frame.show-music #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-music #music-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 音乐页浮上来 */
        }

        /* 内容区域新样式 */
        .content {
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            /* <<< 修改为 flex-end */
            align-items: center;
            height: 100%;
            box-sizing: border-box;
        }

        /* === 新增：顶部内容样式 === */
        .header-content {
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* 时钟容器 */
        .clock {
            display: flex;
            /* 使用flex布局 */
            align-items: center;
            /* 垂直居中对齐 */
            justify-content: center;
            gap: 2px;
            /* 数字间的细微间距 */
            width: 240px;
            /* 给予足够宽度 */
        }

        /* 时钟数字的通用样式 */
        .clock span {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            font-size: 100px;
            font-weight: 700;
            color: #000;
            /* 根据您的新图，颜色改为了黑色 */
            line-height: 1;
            /* 修正行高防止额外空间 */
        }

        /* 冒号的特定样式，使其稳定不跳动 */
        .clock span:nth-child(2) {
            font-weight: 700;
            position: relative;
            top: -0.1em;
            /* 微调垂直位置 */
            animation: blink 1.5s infinite;
            /* 添加闪烁效果 */
        }

        @keyframes blink {
            50% {
                opacity: 0;
            }
        }



        /* 语录容器 */
        .motto-container {
            margin-top: 10px;
            margin-bottom: 30px;
        }

        /* 语录文字样式 */
        #motto {
            font-size: 16px;
            color: #8a8a8e;
            font-weight: 500;
            border: none;
            /* 移除边框 */
            padding: 5px 10px;
            /* 增加一点内边距 */
            border-radius: 5px;
            /* 轻微圆角 */
            cursor: text;
            /* 鼠标样式为文本输入 */
        }

        /* 当用户点击编辑时，提供一个清晰的轮廓 */
        #motto:focus {
            outline: 2px solid #007aff;
            /* 编辑时的蓝色外框 */
            background-color: #f0f2f5;
        }

        /* === 修改：调整整体布局 === */
        .content {
            padding: 60px 0 50px 0;
            /* 调整上下内边距 */
            display: flex;
            flex-direction: column;
            /* 核心改动：让元素之间自动分布空间，顶部贴顶，底部贴底 */
            justify-content: space-between;
            align-items: center;
            height: 100%;
            box-sizing: border-box;
        }

        /* 调整小组件的上下间距为0，因为 space-between 会自动处理 */
        .widget-placeholder {
            margin-bottom: 0;
        }

        /* ===小组件(Widget)区域样式 === */
        .widget-placeholder {
            width: 285px;
            /* 宽度与App区域一致 */
            height: 145px;
            /* 大约两行App的高度 */
            margin-bottom: 40px;
            /* 与下方App的间距 */
            background-color: #f0f2f5;
            border: 2px dashed #d1d1d6;
            /* 虚线边框 */
            border-radius: 22px;
            /* 圆角 */
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            /* 鼠标悬浮时显示手形 */
            color: #8e8e93;
            font-size: 16px;
            transition: background-color 0.3s;

            /* 用于显示上传后的图片 */
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .widget-placeholder:hover {
            background-color: #e1e3e6;
        }

        /* App 图标网格布局 */
        .app-grid {
            display: grid;
            /* 创建4个等宽的列 */
            grid-template-columns: repeat(4, 1fr);
            /* 定义行与列之间的间距 */
            row-gap: 30px;
            column-gap: 15px;
            padding: 20px;
        }

        /* 单个App的容器 (图标 + 名称) */
        .app-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
        }

        /* App图标样式 */
        .app-icon {
            width: 60px;
            height: 60px;
            border-radius: 15px;
            /* 圆角效果 */
            margin-bottom: -20px;
            /* 核心：为图标添加阴影 */
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
            /* 用于垂直居中图标内的元素（例如emoji或文字） */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 30px;
            /* 如果用emoji当图标，可以调整大小 */
            color: white;
        }

        /* App名称样式 */
        .app-name {
            font-size: 12px;
            color: #111;
            font-weight: 500;
            /* 核心：为文字添加轻微阴影 */
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.40);
            transform: translateY(24px);
        }


        /* 新增：App图标中图片的样式 */
        .app-icon img {
            width: 100%;
            height: 100%;
            /* 让图片本身也带圆角，这样即使是直角图片也能完美显示 */
            border-radius: 15px;
            /* object-fit: cover; 属性可以防止图片因拉伸而变形 */
            object-fit: cover;
        }

        /* === 新增：设置页面的专属样式 === */
        .settings-header {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            padding-top: 45px;
            /* 为顶部的刘海留出空间 */
            border-bottom: 1px solid #e5e5e5;
            position: absolute;
            /* 改为绝对定位，使其脱离文档流 */
            top: 0;
            left: 0;
            right: 0;
            background-color: #fff;
            /* 确保有背景色 */
            flex-shrink: 0;
            /* 防止顶栏在空间不足时被压缩 */
            z-index: 10;
            /* 让顶栏在内容之上 */
        }

        .app-back-button {
            background: none;
            border: none;
            font-weight: bold;
            color: #007aff;
            cursor: pointer;
            padding: 0 10px;
            margin-top: 5px;
        }

        .settings-header h1 {
            font-size: 18px;
            font-weight: 400;
            color: #111;
            margin: 0;
            /* 让标题在剩余空间里居中 */
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        #save-settings-button {
            padding: 4px 10px;

            font-size: 12px;

            font-weight: 400;

            color: #007AFF;

            background-color: rgba(0, 122, 255, 0.1);

            border: none;

            border-radius: 40px;

            cursor: pointer;
            margin-left: auto;

            transition: background-color 0.2s;
        }

/* === 唯一的、修正后的 settings-content 样式 === */
.settings-content {
    /* ▼▼▼ 新增/修改 ▼▼▼ */
    padding-top: 90px;  /* 为固定的顶栏留出足够的空间 */
    padding-left: 0;
    padding-right: 0;
    padding-bottom: 20px;

    color: #333;
    display: flex;
    flex-direction: column;
    gap: 18px;
    /* 核心：强制所有子元素在水平方向上居中 */
    align-items: center;
}

        /* Add this new rule anywhere in your styles */
        .modal-body .form-group {
            width: 100%;
        }



        .form-group {
            width: 320px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* 标签和输入框之间的间距 */
        }

        .form-group label {
            font-size: 15px;
            font-weight: 500;
            color: #333;
            padding-left: 5px;
        }

        .form-input,
        .form-select {
            width: 93%;
            height: 40px;
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            font-size: 14px;
            outline: none;
        }

        .form-select:disabled {
            background-color: #f5f5f5;
            color: #c7c7cd;
        }

        .form-button {
            padding: 6px 15px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .form-button:disabled {
            background-color: #8E8E93;
            cursor: not-allowed;
        }

        /* --- 滑块样式 --- */
        .form-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100%;
            height: 3px;
            background: linear-gradient(to right, #6fa8e5 0%, #6fa8e5 var(--progress-percent, 50%), #E5E5EA var(--progress-percent, 50%), #E5E5EA 100%);
            border-radius: 2px;
            outline: none;
        }

        .form-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 0.5px solid rgba(0, 0, 0, 0.04);
            box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 2px 3px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }

        .form-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #FFFFFF;
            border-radius: 50%;
            border: 0.5px solid rgba(0, 0, 0, 0.04);
            box-shadow: 0px 0.5px 4px rgba(0, 0, 0, 0.12), 0px 2px 3px rgba(0, 0, 0, 0.15);
            cursor: pointer;
        }


        /* === 新增：壁纸设置控件的样式 === */
        /* 用这段代码替换掉您已有的 .wallpaper-controls 样式 */
        .wallpaper-controls {
            display: flex;
            align-items: center;
            gap: 15px;
            /* 预览图和按钮组之间的间距 */
        }

        /* 新增：壁纸预览图样式 (尺寸调整) */
        #wallpaper-preview {
            width: 50px;
            height: 88px;
            /* 保持一个合适的手机壁纸比例 */
            border-radius: 6px;
            border: 1px solid #d1d1d6;
            background-color: #e9e9eb;
            background-size: cover;
            background-position: center;
            flex-shrink: 0;
        }

        /* 新增：两个按钮的容器样式 */
        .wallpaper-buttons {
            flex-grow: 1;
            /* 占满剩余空间 */
            display: flex;
            flex-direction: column;
            /* 让两个按钮垂直堆叠 */
            gap: 8px;
            /* 两个按钮之间的间距 */
        }

        /* 这是一个次要按钮的样式，区别于主要的蓝色按钮 */
        .form-button-secondary {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }

        /* --- 关键修改：确保只有主屏幕有壁纸 --- */
        #home-screen {
            background-size: cover;
            background-position: center;
            background-color: transparent;
            /* 让主屏幕背景透明，以便显示壁纸 */
        }

        #settings-screen {
            background-color: #fff;
            /* 确保设置页始终是白色背景 */
        }

        /* === 新增：用于隐藏小组件的类 === */
        .widget-hidden {
            display: none !important;
        }

        /* === 新增：开关(Toggle Switch)样式 === */
        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }

        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 20px;
            width: 20px;
            left: 0px;
            bottom: 0px;
            background-color: white;
            transition: .4s;
        }

        input:checked+.slider {
            background-color: #6fa8e5;
        }

        input:focus+.slider {
            box-shadow: 0 0 1px #6fa8e5;
        }

        input:checked+.slider:before {
            transform: translateX(25px);
        }

        .slider.round {
            border-radius: 34px;
        }

        .slider.round:before {
            border-radius: 50%;
        }

        /* === 新增：响应式缩放，修复小屏幕下的显示问题 === */

        /* 这是一个媒体查询，它表示：
   “如果浏览器窗口的宽度小于或等于 420px 时...” 
*/
        @media (max-width: 420px) {
            .phone-frame {
                /* * “...就把 .phone-frame 这个元素（包括它里面的所有内容）
         * 等比例缩小到原来的 90%。”
         * 这样它就不会超出窄屏幕的边界了。
        */
                transform: scale(0.9);
            }
        }

        /* * 你还可以为更小的屏幕添加进一步的缩放规则，
 * 例如，当屏幕宽度小于 380px 时，再缩小一点。
*/
        @media (max-width: 380px) {
            .phone-frame {
                transform: scale(0.85);
            }
        }

        /* === 音乐 App 专属样式 (新版) === */

        /* 新建歌单按钮的新样式 */
        .add-playlist-button {
            display: block;
            margin: 0 auto;
            width: 100%;
            /* 按钮宽度占满容器 */
            padding: 10px;
            margin-bottom: 20px;
            /* 与下方歌单网格的间距 */
            font-size: 16px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 8px;
            /* 圆角 */
            cursor: pointer;
            text-align: center;
            /* 文字居中 */
            transition: background-color 0.2s;

        }

        .add-playlist-button:hover {
            background-color: #e1e3e6;
            /* 鼠标悬浮时颜色加深 */
        }


        /* 音乐内容区域 */
        .music-content {
            padding: 15px;
            flex-grow: 1;
            /* 关键：让这个区域占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 内容超出这个区域时，允许垂直滚动 */
        }

        /* 歌单网格布局（瀑布流） */
        .playlist-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
        }

        /* 单个歌单卡片的样式 */
        .playlist-card {
            display: flex;
            flex-direction: column;
            cursor: pointer;
            transition: transform 0.2s ease-in-out;
        }

        .playlist-card:hover {
            transform: scale(1.03);
        }

        /* 歌单封面 */
        .playlist-cover {
            width: 100%;
            padding-bottom: 100%;
            background-color: #e9e9eb;
            border-radius: 8px;
            margin-bottom: 8px;
            background-size: cover;
            /* 关键：让图片缩放以完全覆盖容器 */
            background-position: center;
            /* 辅助：让图片在容器里居中显示 */
        }

        /* 歌单名称 */
        .playlist-name {
            font-size: 14px;
            font-weight: 500;
            color: #1c1c1e;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* 歌单歌曲数量 */
        .playlist-count {
            font-size: 12px;
            color: #8a8a8e;
        }

        /* === 新增：歌单详情页的动画控制 === */
        #playlist-detail-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 3;
            /* 层级比音乐主页更高 */
            background-color: #fff;
            /* 确保有白色背景 */
            display: flex;
            /* 使用 flex 布局 */
            flex-direction: column;
            /* 垂直排列 */
        }

        .phone-frame.show-playlist-detail #playlist-detail-screen {
            opacity: 1;
            pointer-events: auto;
        }

        /* 详情页顶栏样式 */
        .playlist-header {
            border-bottom: 1px solid #f0f0f0;
        }

        /* 详情页内容区 */
        .playlist-content {
            padding: 20px;
            flex-grow: 1;
            /* 占据剩余所有空间 */
            overflow-y: auto;
            /* 内容多时可以滚动 */
        }

        /* 导入按钮样式 */
        .import-button {
            display: block;
            /* 块级元素 */
            width: 120px;
            /* 固定宽度 */
            margin: 0 auto 25px auto;
            /* 水平居中，并和下方列表拉开距离 */
            padding: 8px 16px;
            font-size: 15px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: 1px solid #ffffff;
            border-radius: 20px;
            /* 圆角 */
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        /* 歌曲列表样式 */
        .song-list {
            list-style: none;
            /* 移除默认的圆点 */
            padding: 0;
            margin: 0;
        }

        /* 列表中的每一项 */
        .song-item {
            border-bottom: 1px solid #f0f0f0;
            padding: 12px 5px;
        }

        /* === 新增：播放按钮和歌曲列表项新布局 === */
        .song-item {
            display: flex;
            justify-content: space-between;
            /* 两端对齐 */
            align-items: center;
            /* 垂直居中 */
            border-bottom: 1px solid #f0f0f0;
            padding: 12px 5px;
        }

        .song-info {
            /* 这个新容器用来包裹歌名和歌手 */
            display: flex;
            flex-direction: column;
        }

        .play-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 5px;
            width: 32px;
            /* 固定宽度 */
            height: 32px;
            /* 固定高度 */
        }

        .play-button svg {
            width: 100%;
            height: 100%;
        }

        /* === 新增：详情页顶栏右侧按钮 === */
        .header-actions {
            margin-left: auto;
            /* 关键：将按钮组推到最右边 */
            display: flex;
            gap: 10px;
            /* 按钮之间的间距 */
        }

        .header-button {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        /* 删除按钮的特殊样式 */
        .header-button.delete {
            border-color: #ff3b30;
            color: #ff3b30;
        }

        /* === 新增：多选删除模式下的样式 === */
        .song-item .song-checkbox {
            display: none;
            /* 默认隐藏复选框 */
            margin-right: 15px;
            /* 和歌曲信息拉开距离 */
        }

        /* 当 song-list 处于删除模式时，显示复选框 */
        .song-list.delete-mode .song-checkbox {
            display: block;
        }

        /* === 新增：统一的头部文本按钮样式 === */
        .header-text-button {
            padding: 4px 10px;
            font-size: 12px;
            font-weight: 400;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 40px;
            cursor: pointer;
            transition: background-color 0.2s;
            /* 用于在flex布局中对齐 */
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .header-text-button:hover {
            background-color: rgba(0, 122, 255, 0.2);
        }


        /* === 新增：世界书App的动画控制 === */
        /* 默认状态：世界书页完全透明，并且无法交互 */
        #worldbook-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 默认在下层 */
        }

        /* 当 phone-frame 拥有 .show-worldbook 类名时 */
        .phone-frame.show-worldbook #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-worldbook #worldbook-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 世界书页浮上来 */
        }

        /* === 新增：消息App的动画控制 === */
        /* 默认状态：消息页完全透明，并且无法交互 */
        #messages-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        /* 当 phone-frame 拥有 .show-messages 类名时 */
        .phone-frame.show-messages #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-messages #messages-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 消息页浮上来 */
        }

        .dynamic-island {
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 999;

            /* === 核心修改在这里 === */
            width: 180px;
            height: 36px;
            padding: 0 18px;
            /* 在左右两边增加内边距，让内容和黑边有呼吸空间 */
            box-sizing: border-box;
            /* 确保 padding 不会影响最终的宽高计算 */

            background-color: #000;
            border-radius: 40px;
            color: white;
            transition: all 0.35s cubic-bezier(0.65, 0, 0.35, 1);
            opacity: 0;
            pointer-events: none;
            cursor: pointer;
        }

        .dynamic-island.active {
            opacity: 1;
            pointer-events: auto;
        }

        /* 展开状态的尺寸 */
        .dynamic-island.expanded {
            width: 336px;
            /* 展开后的宽度 */
            height: 160px;
            /* 展开后的高度 */
        }

        /* --- 收起/展开内容的切换 --- */
        .island-collapsed-content {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            opacity: 1;
            transition: opacity 0.2s ease-out;
        }

        .dynamic-island.expanded .island-collapsed-content {
            opacity: 0;
            pointer-events: none;
        }

        /* === 用下面这段新的代码替换上面的旧代码 === */

        .island-expanded-content {
            /* --- 关键修复：添加绝对定位 --- */
            position: absolute;
            top: 0;
            left: 0;

            width: 100%;
            height: 100%;
            padding: 18px;
            box-sizing: border-box;

            /* 使用 Flexbox 布局来排列内部元素 */
            display: flex;
            flex-direction: column;
            justify-content: space-around;
            /* 垂直方向上均匀分布 */

            opacity: 0;
            transition: opacity 0.2s ease-out;
            pointer-events: none;
            /* 在隐藏时确保无法交互 */
        }

        .dynamic-island.expanded .island-expanded-content {
            opacity: 1;
            pointer-events: auto;
            transition: opacity 0.3s 0.15s ease-in;
        }


        /* --- 内部元素样式 --- */
        /* === 用下面这段新的代码替换上面的旧代码 === */

        /* 使用 .dynamic-island 来提高优先级，确保样式只应用在灵动岛内部 */
        .dynamic-island .song-details .song-title {
            font-size: 18px;
            font-weight: bold;
            color: #FFFFFF;
            /* 强制指定为白色 */
        }

        .dynamic-island .song-details .song-artist {
            font-size: 14px;
            color: #b2b2b2;
            /* 一个更亮的灰色，在黑背景上更清晰 */
        }

        .progress-container {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            color: #aaa;
        }

        .progress-bar-wrapper {
            flex-grow: 1;
            height: 6px;
            background-color: #333;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar-fill {
            width: 0%;
            height: 100%;
            background-color: #fff;
            border-radius: 3px;
        }

        .controls-container {
            display: flex;
            justify-content: space-around;
            align-items: center;
        }

        .control-button {
            background: none;
            border: none;
            width: 40px;
            height: 40px;
            cursor: pointer;
        }

        .control-button svg {
            fill: #fff;
            width: 100%;
            height: 100%;
        }

        .control-button.play-pause {
            width: 50px;
            height: 50px;
        }

        .play-icon,
        .pause-icon {
            display: none;
        }

        .control-button.play .play-icon,
        .control-button.pause .pause-icon {
            display: block;
        }

        /* 强制提升控制按钮容器的层级 */
        .dynamic-island .controls-container {
            position: relative;
            /* z-index 生效需要 position 属性 */
            z-index: 10;
        }

        /* === 新增：联系人弹出层 (Modal) 的所有样式 === */

        /* 1. 遮罩背景 */
        .modal-overlay {
            position: absolute;
            /* 相对于 .phone-frame 定位 */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            /* 半透明黑色背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            /* 确保在最顶层 */
            opacity: 0;
            /* 默认透明 */
            transition: opacity 0.3s ease;
            /* 淡入淡出动画 */
        }

        /* 2. 对话框主体 */
        .modal-content {
            background-color: #f7f7f7;
            padding: 20px;
            border-radius: 18px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 270px;
            max-width: 340px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* 内部元素的间距 */
            transform: scale(0.95);
            /* 默认稍微缩小 */
            transition: transform 0.3s ease;
            /* 缩放动画 */
        }

        /* 当 .modal-overlay 显示时，让 .modal-content 动画出现 */
        .modal-overlay.visible .modal-content {
            transform: scale(1);
        }


        /* 3. 顶部滑块和关闭按钮 */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .role-switcher {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            font-weight: 500;
        }

        .switch-label {
            color: #888;
            transition: color 0.3s;
        }

        .switch-label.active {
            color: #007AFF;
        }

        .modal-close-button {
            background: none;
            border: none;
            font-size: 28px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
        }

        /* 4. AI 和用户表单的样式 */
        .role-form {
            display: none;
            /* 默认隐藏 */
            flex-direction: column;
            align-items: center;
            gap: 12px;
        }

        .role-form.active {
            display: flex;
            /* .active 类使其显示 */
        }

        .avatar-uploader {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }

        .avatar-preview {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            /* 圆形头像 */
            object-fit: cover;
            border: 2px solid #e0e0e0;
        }

        .avatar-input {
            display: none;
            /* 隐藏原始的文件选择框 */
        }

        .avatar-upload-label {
            font-size: 12px;
            color: #007AFF;
            cursor: pointer;
        }

        .form-textarea {
            width: 95%;
            height: 100px;
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            font-size: 14px;
            padding: 10px;
            box-sizing: border-box;
            resize: vertical;
            /* 允许用户垂直调整大小 */
        }

        /* 5. 底部公共部分 */
        .modal-footer {
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid #e5e5e5;
            padding-top: 15px;
        }

        .form-group-inline {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .form-group-inline input {
            width: 60px;
            text-align: center;
        }

        .save-button {
            width: 95%;
            padding: 12px;
            font-size: 16px;
            font-weight: 500;
            color: #fff;
            background-color: #007AFF;
            border: none;
            border-radius: 12px;
            cursor: pointer;
        }

        /* === 新增：消息列表的样式 === */
        .contact-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .contact-item {
            display: flex;
            align-items: center;
            padding: 10px 15px;
            border-bottom: 1px solid #f0f0f0;
            cursor: pointer;
        }

        .contact-item:hover {
            background-color: #f9f9f9;
        }

        .contact-avatar {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 15px;
        }

        .contact-info {
            flex-grow: 1;
            min-width: 0;
        }

        .contact-name {
            font-size: 16px;
            font-weight: 500;
            color: #111;
        }

        .contact-last-message {
            font-size: 14px;
            color: #888;
            margin-top: 4px;
            /* 防止文字过长换行 */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* === 新增：消息列表多选删除模式的样式 === */

        /* 1. 默认隐藏列表项中的复选框 */
        .contact-item .contact-checkbox {
            display: none;
            margin-right: 15px;
            /* 和头像拉开距离 */
        }

        /* 2. 当列表进入删除模式时，显示复选框 */
        .contact-list.delete-mode .contact-item .contact-checkbox {
            display: block;
            /* block 会让它显示出来 */
        }

        /* 3. 删除模式下，列表项内边距微调，给复选框留出空间 */
        .contact-list.delete-mode .contact-item {
            padding-left: 10px;
        }

        /* 4. 删除按钮的特殊红色样式 (复用音乐App的样式) */
        .header-button.delete {
            color: #ff3b30;
            /* 红色文字 */
        }

        /* === 新增：聊天界面的所有样式 === */

        /* 1. 聊天界面整体和滑入动画 */
        #chat-screen {
            /* 初始状态：透明且略微放大 */
            opacity: 0;
            transform: scale(1.05);
            pointer-events: none;
            /* 隐藏时不可交互 */
            transition: opacity 0.3s ease, transform 0.3s ease;
            /* 让透明度和缩放同时产生动画 */
            z-index: 4;
            background-color: #f0f2f5;
            display: flex;
            flex-direction: column;
            height: 100%;
            /* vvv 新增：控制背景图的显示方式 vvv */
            background-size: cover;
            /* 关键：让背景图缩放以完全覆盖容器 */
            background-position: center;
            /* 辅助：让图片在容器里居中显示 */
            background-repeat: no-repeat;
            /* 辅助：防止图片在尺寸不匹配时平铺 */
            --emoji-panel-height: 200px;
        }

        /* 当 phone-frame 拥有 .show-chat 类名时 */
        .phone-frame.show-chat #chat-screen {
            /* 结束状态：完全不透明且正常大小 */
            opacity: 1;
            transform: scale(1);
            pointer-events: auto;
            /* 激活后可交互 */
        }

        /* (可选) 让消息列表页向左滑出，效果更佳 */
        .phone-frame.show-chat #messages-screen {
            /* 让消息列表页直接淡出，而不是缩小 */
            opacity: 0;
            pointer-events: none;
        }


        /* 2. 固定的高斯模糊顶栏 */
        .chat-header {
            /* 继承通用顶栏样式，但需要覆盖一些属性 */
            position: absolute;
            /* 改为绝对定位，固定在顶部 */
            top: 0;
            left: 0;
            right: 0;
            display: flex;
            align-items: center;
            padding: 10px 15px;
            padding-top: 45px;
            /* 为手机刘海留出空间 */
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
            z-index: 10;

            /* --- 高斯模糊核心样式 --- */
            background-color: rgba(255, 255, 255, 0.85);
            /* 必须是半透明背景 */
            -webkit-backdrop-filter: blur(10px);
            /* 兼容 Safari */
            backdrop-filter: blur(10px);
            /* 标准语法 */
        }

        .chat-header h1 {
            /* 继承通用标题样式 */
            font-size: 17px;
            font-weight: 400;
            color: #111;
            margin: 0;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            white-space: nowrap;
        }

        /* 让右侧按钮自动靠右 */
        .chat-header #chat-settings-button {
            margin-left: auto;
        }


        /* 3. 聊天消息容器 */
        .chat-messages-container {
            flex-grow: 1;
            /* 占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 内容超出时可以滚动 */
            padding: 10px;
            /* --- 关键：为固定的顶栏和底栏留出空间 --- */
            padding-top: 90px;
            /* 约等于顶栏高度 */
            padding-bottom: 70px;
            /* 约等于底栏高度 */
        }


        /* 新增：为左右两个圆形按钮创建一个通用样式 */
        .chat-action-button {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background-color: transparent;
            /* 默认所有按钮背景都透明 */
            /* 移除 font-size 和 line-height，因为现在由 SVG 控制 */
        }

        /* 2. 加号按钮的特定样式 */
        #chat-add-attachment-button {
            background-color: #e9e9eb;
            color: #333;
            /* SVG 将继承这个颜色 */
        }

        /* 3. 新增：为加号按钮内的 SVG 设置样式 */
        #chat-add-attachment-button svg {
            width: 24px;
            height: 24px;
        }

        #chat-add-attachment-button svg path {
            fill: currentColor;
            /* 关键：让 SVG 颜色跟随按钮的 color 属性 */
        }

        /* 更新：输入框样式 */
        .chat-input-area input {
            width: 70%;
            height: 40px;
            border: none;
            background-color: #ffffff;
            /* 改为白色背景，更清晰 */
            border-radius: 20px;
            padding: 0 15px;
            font-size: 15px;
            outline: none;
        }

        /* 新增：控制发送按钮内部SVG的样式 */
        #chat-send-button svg {
            width: 24px;
            height: 24px;
        }

        #chat-send-button svg path {
            fill: currentColor;
            /* 关键：让SVG的路径颜色继承父按钮的color属性 (白色) */
        }

        /* === 新增：聊天设置、气泡、输入栏的最终正确样式 === */

        /* --- 1. 聊天设置对话框 --- */
        .modal-content.large {
            max-width: 350px;
            max-height: 85%;
            gap: 0;
            display: flex;
            flex-direction: column;
        }

        .modal-content.large .modal-header,
        .modal-content.large .modal-footer {
            flex-shrink: 0;
        }

        .modal-content.large .modal-header {
            padding-bottom: 10px;
            border-bottom: 1px solid #e5e5e5;
        }

        .modal-content.large .modal-header h2 {
            font-size: 18px;
            margin: 0;
        }

        .modal-body {
            display: flex;
            flex-direction: column;
            gap: 25px;
            padding: 15px 5px;
            overflow-y: auto;
            flex-grow: 1;
        }

        .settings-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .settings-column h4 {
            font-size: 16px;
            margin: 0 0 5px 0;
            color: #333;
            padding-bottom: 8px;
            border-bottom: 1px solid #eee;
        }

        .form-textarea.code {
            font-family: monospace;
            height: 120px;
            white-space: pre;
            font-size: 12px;
            width: 100%;
        }

        .form-button-secondary.small {
            padding: 6px 10px;
            font-size: 14px;
        }

        .danger-zone {
            border-top: 1px solid #e5e5e5;
            padding-top: 15px;
        }

        .danger-button {
            width: 100%;
            padding: 10px;
            font-size: 14px;
            font-weight: 500;
            color: #ff3b30;
            background-color: rgba(255, 59, 48, 0.1);
            border: 1px solid rgba(255, 59, 48, 0.2);
            border-radius: 8px;
            cursor: pointer;
        }

        /* 关键修复：确保头像设置的行内元素能正确布局 */
        .form-group .form-group-inline {
            display: flex;
            justify-content: space-between;
            /* 两端对齐 */
            align-items: center;
        }

        .form-group .form-group-inline .form-input {
            flex-grow: 0;
            /* 禁止它伸展 */
        }



        .ai-bubble {
            background-color: #E5E5EA;
            color: black;
            border-bottom-left-radius: 4px;
        }

        .message-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            width: 100%;
            animation: bubble-scale-in 0.3s ease-out;
        }

        .message-row.user {
            flex-direction: row-reverse;
            transform-origin: bottom right;
            padding-left: 15%;
        }

        .message-row.ai {
            transform-origin: bottom left;
            padding-right: 15%;
        }

        .hide-avatars .chat-avatar {
            display: none;
        }

        .hide-avatars .message-row.user {
            justify-content: flex-end;
        }

        .chat-messages-container {
            display: flex;
            flex-direction: column;
        }


        /* --- 3. 聊天输入栏 --- */
        .chat-input-area {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            /* 明确宽度 */
            display: flex;
            align-items: center;
            padding: 8px 12px;
            padding-bottom: 25px;
            background-color: #ffffff;
            border-top: 1px solid #dcdcdc;
            gap: 10px;
            box-sizing: border-box;
            /* 关键修复：确保 padding 不会撑大宽度 */
            z-index: 20;
        }

        .chat-action-button {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
            background-color: transparent;
        }

        #chat-add-attachment-button {
            color: #333;
        }

        #chat-add-attachment-button svg {
            width: 26px;
            height: 26px;
        }

        #chat-add-attachment-button svg path {
            fill: currentColor;
        }

        .chat-input-area input {
            flex-grow: 1;
            height: 40px;
            border: none;
            background-color: #e5e5e5;
            border-radius: 20px;
            padding: 0 15px;
            font-size: 15px;
            outline: none;
        }

        #chat-send-button {
            background-color: #007AFF;
            color: white;
        }

        #chat-send-button svg {
            width: 24px;
            height: 24px;
        }

        #chat-send-button svg path {
            fill: currentColor;
        }


        /* === 更新：更多功能面板的样式 (竖向布局) === */
        .features-panel {
            position: absolute;
            bottom: 70px;
            /* 定位在输入栏上方 */
            left: 8px;
            /* 靠手机框左边 */
            background-color: rgba(245, 245, 245, 0.95);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border-radius: 18px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            padding: 12px;
            /* 增加内边距 */
            box-sizing: border-box;

            opacity: 0;
            transform: translateY(15px) scale(0.95);
            transition: opacity 0.25s ease-out, transform 0.25s ease-out;
            pointer-events: none;
            z-index: 50;
        }

        .features-panel.active {
            opacity: 1;
            transform: translateY(0) scale(0.8);
            pointer-events: auto;
        }

        /* 将 grid 布局改为 flex 竖向布局 */
        .features-grid {
            display: flex;
            flex-direction: column;
            /* 核心：设置为竖向排列 */
            gap: 8px;
            /* 项目之间的间距 */
        }

        /* 将项目内部改为横向布局 (图标 | 文字) */
        .feature-item {
            display: flex;
            flex-direction: row;
            /* 核心：图标和文字横向排列 */
            align-items: center;
            /* 垂直居中对齐 */
            gap: 12px;
            /* 图标和文字之间的间距 */
            cursor: pointer;
            border-radius: 10px;
            transition: background-color 0.2s;
            /* 添加悬停效果 */
        }

        /* 新增：鼠标悬停时高亮背景 */
        .feature-item:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        .feature-icon {
            width: 40px;
            /* 可以适当调小图标背景 */
            height: 40px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            /* 防止图标被压缩 */
        }

        /* 新增：控制SVG图标的样式 */
        .feature-icon svg {
            width: 24px;
            height: 24px;
            fill: #333;
            /* 用CSS控制颜色 */
        }

        .feature-name {
            font-size: 14px;
            /* 可以适当调大字体 */
            color: #1c1c1e;
            font-weight: 500;
        }

        @keyframes bubble-scale-in {

            /* 动画开始时：完全透明，且只有正常大小的80% */
            from {
                opacity: 0;
                transform: scale(0.8);
            }

            /* 动画结束时：完全不透明，恢复正常大小 */
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        /* === 新增：“正在输入”提示的CSS样式 === */

        /* 动画容器的样式 */
        .typing-animation {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 16px;
            /* 控制整体高度 */
        }

        /* 动画点的基础样式 */
        .typing-dot {
            width: 6px;
            height: 6px;
            margin: 0 2px;
            background-color: #8E8E93;
            /* 点的颜色 */
            border-radius: 50%;

            /* 应用我们下面定义的动画 */
            animation: typing-bounce 1.2s infinite ease-in-out;
        }

        /* 为第二个和第三个点设置动画延迟，形成波浪效果 */
        .typing-dot:nth-child(2) {
            animation-delay: 0.15s;
        }

        .typing-dot:nth-child(3) {
            animation-delay: 0.3s;
        }

        /* 定义一个名为 "typing-bounce" 的动画 */
        @keyframes typing-bounce {

            0%,
            80%,
            100% {
                transform: scale(0);
                /* 开始、快结束和结束时，点是缩小的 */
            }

            40% {
                transform: scale(1.0);
                /* 动画进行到40%时，点放大到最大 */
            }
        }

        /* --- 新增：消息选择功能的CSS样式 --- */
        /* --- 这是消息布局的【最终修复版】CSS --- */

        /* 1. 外层行容器：永远100%宽度，用于对齐选择器 */
        .message-row {
            position: relative;
            display: flex;
            margin-bottom: 10px;
            width: 100%;
            box-sizing: border-box;
        }

        /* 2. 新增！内容包装层：负责对齐和限制宽度 */
        .message-content-wrapper {
            display: flex;
            align-items: flex-end;
            max-width: 85%;
            /* 约束内容最大宽度 */
            transition: transform 0.3s ease;
            /* 动画效果 */
        }

        .message-content-wrapper.user {
            margin-left: auto;
            /* 关键：将用户的内容推到最右边 */
            flex-direction: row-reverse;
            /* 头像在右，气泡在左 */
        }

        /* 3. 气泡、头像和选择器样式 (基本不变，但选择器更准确) */
        .chat-bubble {
            padding: 10px 15px;
            border-radius: 18px;
            line-height: 1.4;
            word-wrap: break-word;
            font-size: 13.5px;
            min-width: 0;
            /* 确保能正确换行 */
        }

        .ai-bubble {
            background-color: #E5E5EA;
            color: black;
            border-bottom-left-radius: 4px;
        }

        .chat-avatar {
            width: 40px;
            height: 40px;
            object-fit: cover;
            flex-shrink: 0;
            margin: 0 8px;
        }

        .selection-indicator {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 20px;
            height: 20px;
            border: 2px solid #c7c7cc;
            border-radius: 50%;
            background-color: #fff;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 4. 选择模式下的样式 (选择器更精确) */
        .selection-mode-active .selection-indicator {
            opacity: 1;
        }

        .selection-mode-active .message-row {
            /* 注意是 message-row */
            background-color: rgba(0, 122, 255, 0.0);
            /* 移除之前的选中背景色 */
        }

        .message-row.selected {
            background-color: transparent;
        }

        .message-row.selected .selection-indicator {
            background-color: #007aff;
            border-color: #007aff;
        }

        .message-row.selected .selection-indicator::after {
            content: '✔';
            color: white;
            font-size: 12px;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        /* 5. 【关键】选择模式下的平移动画 (最终加强版) */
        #chat-screen.selection-mode-active .message-content-wrapper.ai {
            transform: translateX(30px) !important;
        }

        /* === 新增：全屏模式的样式 === */
        body.fullscreen-mode {
            /* 1. 取消强制居中，让内容从左上角开始 */
            display: block;
            /* 2. 背景设为干净的白色 */
            background-color: #fff;
            /* 3. 新增：在全屏模式下，禁止整个页面滚动 */
    overflow: hidden;
        }

        body.fullscreen-mode .phone-frame {
            /* 3. 覆盖固定的宽高，让它占满整个屏幕 */
            width: 100%;
            height: 100vh;
            /* vh 单位代表视口高度 */
            max-width: none;
            max-height: none;

            /* 4. 移除所有手机框的视觉样式 */
            border: none;
            border-radius: 0;
            box-shadow: none;
            background: #fff;
            /* 背景也设为白色 */

            /* 5. 强制覆盖掉针对小屏幕的 transform: scale 缩放效果 */
            transform: none !important;
        }

        /* === 更新：为悬浮顶栏下的内容区域添加上边距并使其可滚动 === */
        #settings-screen .settings-content,
        #messages-screen .messages-content,
        #playlist-detail-screen .playlist-content {
            padding-top: 90px;
            height: 100%;
            overflow-y: auto;
            box-sizing: border-box;
        }

        /* 将音乐和世界书界面单独设置，使用Flexbox布局 */
        #music-screen .music-content,
        #worldbook-screen .music-content {
            padding: 90px 15px 15px 15px;
            /* 调整内边距，左右也加上 */
            height: 100%;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            /* 垂直排列 */
            gap: 15px;
            /* 按钮和列表的间距 */
        }

        /* === 新增：使“新建”按钮固定 === */
        .add-playlist-button {
            flex-shrink: 0;
            /* 防止按钮在空间不足时被压缩 */
            /* 其他样式保持不变 */
        }

        /* === 新增：让新的列表容器可滚动 === */
        .scrollable-list-container {
            flex-grow: 1;
            /* 占据所有剩余的垂直空间 */
            overflow-y: auto;
            /* 让这个容器自己负责滚动 */
        }

        /* === 最终版：独立转账卡片样式 === */

        /* 1. 卡片主容器 */
        .transfer-card {
            background-color: #F0F0F0;
            /* 独立的浅灰色背景 */
            border: 1px solid #E5E5EA;
            border-radius: 12px;
            /* 使用更像卡片的直角一些的圆角 */
            padding: 16px;
            width: 240px;
            /* 宽度调整为240px，不会显得太大 */
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            gap: 6px;
            /* 调整内部元素间距 */
            color: #000;
            position: relative;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
            /* 添加轻微阴影增加质感 */
        }

        /* 2. 卡片内部元素的样式 */
        .transfer-card .card-title {
            font-size: 16px;
            font-weight: 500;
        }

        .transfer-card .card-remark {
            font-size: 14px;
            color: #8A8A8E;
        }

        .transfer-card .card-amount {
            font-size: 32px;
            font-weight: 400;
            margin-top: 8px;
        }

        .transfer-card .card-icon {
            position: absolute;
            top: 16px;
            right: 16px;
            width: 34px;
            /* 直接为图标容器设置尺寸 */
            height: 28px;
        }

        /* === 新增：世界书多选列表的样式 === */
        .multiselect-container {
            max-height: 120px;
            /* 设置一个最大高度 */
            overflow-y: auto;
            /* 内容超出时出现滚动条 */
            background-color: #e9e9eb;
            border: 1px solid #d1d1d6;
            border-radius: 12px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            /* 选项之间的间距 */
        }

        .multiselect-item {
            display: flex;
            align-items: center;
            gap: 10px;
            /* 复选框和文字的间距 */
            font-size: 14px;
            cursor: pointer;
        }

        /* === 新增：歌单多选删除模式的样式 === */

        /* 1. 让歌单卡片成为复选框的定位基准 */
        .playlist-card {
            position: relative;
        }

        /* 2. 复选框的样式，默认隐藏 */
        .playlist-checkbox {
            display: none;
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            z-index: 5;
            /* 确保在封面之上，可以被点击 */
        }

        /* 3. 当歌单网格进入删除模式时，显示复选框 */
        .playlist-grid.delete-mode .playlist-checkbox {
            display: block;
        }

        /* === 最终版 V2：使用专属类名 chatsearch-content === */

        /* 1. 外部容器样式 (保持不变) */
        .search-result-item {
            display: flex;
            flex-direction: column;
            gap: 4px;
            padding: 6px 8px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .search-result-item:hover {
            background-color: #e9e9eb;
        }

        /* 2. 第一行容器样式 (保持不变) */
        .search-result-item .result-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* 3. 发送者和时间样式 (保持不变) */
        .search-result-item .sender-name {
            font-size: 14px;
            font-weight: 500;
            color: #1c1c1e;
        }

        .search-result-item .time {
            font-size: 12px;
            color: #8a8a8e;
        }

        /* 4. 【核心修改】第二行内容摘要样式，应用到新的类名上 */
        .search-result-item .chatsearch-content {
            font-size: 13px;
            color: #333;
            white-space: nowrap;
            /* 禁止换行 */
            overflow: hidden;
            /* 隐藏溢出部分 */
            text-overflow: ellipsis;
            /* 显示省略号 */
        }

        /* 5. 高亮样式 (保持不变) */
        .search-result-item .highlight {
            background-color: rgba(0, 122, 255, 0.15);
            color: rgb(0, 0, 0);
            border-radius: 3px;
            padding: 0 2px;
        }

        /* 其他相关样式 (保持不变) ... */
        @keyframes temporary-highlight {

            0%,
            100% {
                background-color: transparent;
            }

            20%,
            80% {
                background-color: rgba(0, 122, 255, 0.15);
            }
        }

        .message-highlight {
            animation: temporary-highlight 1.5s ease-out;
        }

        /* 新增：隐藏搜索框内自带的清除按钮(x) */
        #search-input::-webkit-search-cancel-button {
            display: none;
        }



        /* === 用于图标和滚动标题的新样式 === */

        /* 1. 主容器，用于对齐图标和文本 */
        .collapsed-music-info {
            display: flex;
            align-items: center;
            gap: 6px;
            /* 图标和文字之间的间距 */
            width: 100%;
            padding: 0 10px;
            box-sizing: border-box;
        }

        /* 2. SVG 图标的样式 */
        .music-icon-collapsed {
            flex-shrink: 0;
            /* 防止图标被压缩变形 */
        }

        /* 3. “窗口”容器，用于隐藏溢出的文本 */
        .title-scroller-window {
            overflow: hidden;
            /* 关键！隐藏所有超出这个容器的内容 */
            flex-grow: 1;
            /* 让它占据所有剩余的空间 */
        }

        /* 4. 标题文本的基础样式 */
        .collapsed-title {
            color: white;
            font-weight: 400;
            white-space: nowrap;
            /* 强制文本不换行 */
            display: inline-block;
            /* 这是让动画正确工作所必需的 */
        }

        /* 5. 这个类将由 JavaScript 添加，用于激活滚动动画 */
        .collapsed-title.scrolling {
            /* 让文本的起点移动到“窗口”的右侧，为滚动入场做准备 */
            padding-left: 100%;
            /* 应用我们下面定义的 'marquee-scroll' 动画 */
            animation: marquee-scroll 8s linear infinite;
        }

        /* 6. 定义滚动动画的关键帧 */
        @keyframes marquee-scroll {
            0% {
                transform: translateX(0);
            }

            100% {
                /* 将文本向左移动，直到它完全从视野中消失 */
                transform: translateX(-100%);
            }
        }

        /* === 新增：灵动岛展开后顶部的样式 === */
        .expanded-header {
            width: 100%;
            position: relative;
            display: flex;
            justify-content: center;
            /* 左右两端对齐 */
            align-items: flex-start;
            /* 顶部对齐 */
        }

        /* 复用 .song-details 的样式，但确保它不会被压缩 */
        .song-details {
            text-align: center;
            flex-shrink: 0;
        }

        /* 新增的邀请按钮样式 */
        .island-action-button {
            position: absolute;
            top: -5px;
            /* 微调垂直位置 */
            right: -5px;
            /* 微调水平位置 */
            background: none;
            border: none;
            padding: 5px;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.2s;
        }

        .island-action-button:hover {
            opacity: 1;
        }

        /* === 新增：邀请联系人对话框的CSS (这是缺失的样式部分) === */

        /* 对话框的遮罩背景 */
        .modal-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.4);
            display: none;
            /* JS会控制它显示 */
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        /* 对话框主体 */
        .modal-content {
            background-color: #f7f7f7;
            border-radius: 18px;
            box-shadow: 0 5px 25px rgba(0, 0, 0, 0.2);
            width: 300px;
            /* 对话框宽度 */
            max-width: 90%;
            transform: scale(0.95);
            transition: transform 0.3s ease;
        }

        /* 对话框头部 */
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 20px;
            border-bottom: 1px solid #e5e5e5;
        }

        .modal-header h2 {
            margin: 0;
            font-size: 17px;
            font-weight: 500;
        }

        .modal-close-button {
            background: none;
            border: none;
            font-size: 28px;
            color: #aaa;
            cursor: pointer;
            line-height: 1;
        }

        /* 对话框内容区域 */
        .modal-body {
            max-height: 400px;
            overflow-y: auto;
            padding: 10px 0;
        }

        /* 列表项的样式 (这个之前给过，请确保它存在) */
        .invite-contact-item {
            display: flex;
            align-items: center;
            padding: 8px 20px;
            transition: background-color 0.2s;
        }

        .invite-contact-item:hover {
            background-color: #f0f0f0;
        }

        .invite-contact-avatar {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            object-fit: cover;
            margin-right: 12px;
        }

        .invite-contact-name {
            font-size: 16px;
            color: #111;
            flex-grow: 1;
        }

        .invite-button {
            padding: 5px 15px;
            font-size: 13px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border: none;
            border-radius: 20px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .invite-button.invited {
            background-color: #e5e5ea;
            color: #8e8e93;
            cursor: not-allowed;
        }

        /* === 新增：共享听歌重叠头像的样式 === */

        /* 头像容器的样式 */
        .shared-avatars {
            position: absolute;
            /* 绝对定位，浮动在左上角 */
            top: -5px;
            /* 垂直方向微调，使其与歌名对齐 */
            left: 0;
            display: flex;
            /* 使用flex布局来排列头像 */
            align-items: center;
            padding: 2px;
            display: none;
            /* 默认状态下隐藏 */
        }

        /* 当需要显示时，JS会添加这个 .active 类 */
        .shared-avatars.active {
            display: flex;
        }

        /* 单个头像的样式 */
        .shared-avatar-img {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            /* 圆形 */
            border: 2px solid rgba(255, 255, 255, 0.8);
            /* 半透明白色边框，增加质感 */
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            /* 轻微阴影 */
            object-fit: cover;
            /* 防止图片变形 */
        }

        /* 关键：让第二个头像向左移动，与第一个头像重叠 */
        .shared-avatar-img:nth-child(2) {
            margin-left: -12px;
        }

        /* === 新增：“结束一起听”确认气泡的样式 === */
        .confirmation-bubble {
            position: absolute;
            top: 10%;
            left: 250%;
            transform: translateX(-50%);
            margin-top: 8px;

            background-color: rgba(60, 60, 60, 0.85);
            /* 半透明深灰色背景 */
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);

            color: white;
            padding: 8px 12px;
            border-radius: 12px;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);

            display: flex;
            align-items: center;
            gap: 10px;
            white-space: nowrap;
            /* 防止文字换行 */

            /* 默认隐藏，通过JS控制显示 */
            opacity: 0;
            visibility: hidden;
            transform: translateX(-50%) translateY(-5px);
            /* 增加一个轻微的上移动画 */
            transition: opacity 0.2s ease, transform 0.2s ease, visibility 0.2s;
            z-index: 10;
        }

        /* JS添加 .active 类时，气泡显示出来 */
        .confirmation-bubble.active {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        .confirmation-bubble span {
            font-size: 14px;
        }

        .confirmation-bubble button {
            background-color: #ff3b30;
            /* 红色背景 */
            color: white;
            border: none;
            border-radius: 8px;
            padding: 4px 10px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        /* === 新增：用于在聊天界面显示系统提示的样式 === */
        .system-notification {
            text-align: center;
            margin: 10px auto;
            padding: 6px 14px;
            font-size: 12px;
            font-weight: 500;
            color: #007AFF;
            background-color: rgba(0, 122, 255, 0.1);
            border-radius: 20px;
            width: fit-content;
            pointer-events: none;
        }

        /* --- 输入框包装层的正确样式 --- */
        .chat-input-wrapper {
            position: relative;
            /* 这是最关键的一步！为内部的按钮提供定位参考 */
            flex-grow: 1;
            display: flex;
            align-items: center;
        }

        /* --- 表情按钮的正确样式 --- */
        #chat-emoji-button {
            position: absolute;
            /* 绝对定位，会根据上面那个 relative 的父级来定位 */
            right: 5px;
            top: 50%;
            transform: translateY(-50%);
            background-color: #e9e9eb;
            color: #333;
            width: 32px;
            height: 32px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #chat-emoji-button svg {
            width: 20px;
            height: 20px;
        }

        /* --- 输入框的正确样式 --- */
        .chat-input-area input {
            width: 100%;
            padding-right: 42px;
            /* 在右侧留出空间给按钮 */
            box-sizing: border-box;
        }


        /* --- 新增：表情选择面板的样式 --- */

        #emoji-panel {
            position: absolute;
            left: 0;
            width: 100%;
            background-color: #ffffff;
            border-top: 1px solid #dcdcdc;
            z-index: 15;

            /* 使用变量来控制高度 */
            height: var(--emoji-panel-height);

            /* 使用 calc() 函数和变量来计算它的初始隐藏位置 */
            bottom: calc(var(--emoji-panel-height) * -1);

            transition: bottom 0.3s ease-in-out;

            /* === 新增：将其变为垂直弹性布局容器 === */
            display: flex;
            flex-direction: column;
        }


        /* 3. 让其他元素的动画也使用这个变量 */
        .chat-input-area,
        .chat-messages-container {
            transition: bottom 0.3s ease-in-out, padding-bottom 0.3s ease-in-out;
        }


        /* --- 激活状态：所有距离都将根据变量自动计算 --- */

        /* 表情面板上移 */
        #chat-screen.emoji-panel-active #emoji-panel {
            bottom: 0;
        }

        /* 输入栏上移，移动的距离就是变量的值 */
        #chat-screen.emoji-panel-active .chat-input-area {
            bottom: var(--emoji-panel-height);
        }

        /* 消息容器增加内边距，使用 calc() 自动计算总高度 */
        #chat-screen.emoji-panel-active .chat-messages-container {
            padding-bottom: calc(70px + var(--emoji-panel-height));
        }

        /* --- 新增：表情面板内部的样式 --- */

        /* 1. 面板头部的 flex 布局，让按钮分布在两端 */
        .emoji-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 15px;
            /* 上下6px, 左右15px */
            flex-shrink: 0;
            /* 防止头部被压缩 */
        }

        /* 2. 头部按钮的简单样式 */
        .panel-header-button {
            background: none;
            border: none;
            color: #007AFF;
            /* 苹果蓝 */
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
        }

        /* 3. 表情显示的网格容器 */
        /* 3. 表情显示的网格容器 (修正版) */
        #emoji-grid-container {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(55px, 1fr));
            gap: 15px;
            row-gap: 20px;

            padding: 15px;
            box-sizing: border-box;

            /* === 新增/修改：让它占据剩余空间并可以垂直滚动 === */
            flex-grow: 1;
            overflow-y: auto;
        }

        /* 4. 单个表情图片的样式 */
        /* 2. 单个表情图片的样式 (核心修改) */
        .emoji-item {
            width: 100%;
            /* 【关键】强制图片的容器为1:1的正方形 */
            aspect-ratio: 1 / 1;
            /* 【关键】让图片在正方形容器内保持自身比例并完整显示，多余部分留白 */
            object-fit: contain;

            cursor: pointer;
            border-radius: 4px;
            background-color: #fff;
            /* 给图片一个白色背景板，更好看 */
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            /* 添加轻微阴影 */
            transition: transform 0.2s;
        }

        .emoji-item:hover {
            transform: scale(1.1);
            /* 鼠标悬浮时放大一点 */
        }

        /* 3. 表情项外层容器的样式 (保持不变) */
        .emoji-item-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        /* 4. 可编辑备注的样式 (保持不变) */
        .emoji-remark {
            font-size: 11px;
            color: #555;
            background-color: transparent;
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 2px 4px;
            margin: 0;
            text-align: center;
            width: 100%;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .emoji-remark:focus {
            background-color: #fff;
            border: 1px solid #007AFF;
            outline: none;
            white-space: normal;
            overflow: visible;
        }

        /* (可选) 添加这个 CSS 来美化你的表情包 */
        .sticker-bubble {
            padding: 0;
            /* 移除继承自 chat-bubble 的内边距 */
            background-color: transparent;
            /* 移除背景色 */
            max-width: 120px;
            /* 限制表情包最大宽度 */
            max-height: 120px;
            /* 限制表情包最大高度 */
            border-radius: 8px;
            /* 给图片也加个小圆角 */
            object-fit: contain;
            /* 确保图片内容完整显示 */
        }

        /* === 新增：表情包删除模式的样式 === */

        /* 1. 让每个表情包的容器成为复选框的定位基准 */
        .emoji-item-container {
            position: relative;
        }

        /* 2. 复选框的样式，默认隐藏 */
        .emoji-checkbox {
            display: none;
            /* 默认不显示 */
            position: absolute;
            top: -2px;
            right: -2px;
            width: 20px;
            height: 20px;
            z-index: 5;
            /* 确保在图片之上，可以被点击 */
        }

        /* 3. 当网格进入删除模式时，显示复选框 */
        .emoji-grid-container.delete-mode .emoji-checkbox {
            display: block;
        }

        /* 4. (可选) 删除模式下，给选中的表情一个视觉反馈 */
        /* 请只保留下面这一段关于选中样式的 CSS */

        #emoji-grid-container.delete-mode .emoji-item-container.selected {
            aspect-ratio: 1 / 1;
            /* 为了确保这次一定能看到效果，我们使用了一个非常强烈的样式。
    如果这个样式生效了，您可以再把它改成您喜欢的样子。
    */
            border: 3px solid #007AFF !important;
            /* 一个3px宽、不透明的蓝色实线边框 */
            background-color: rgba(0, 122, 255, 0.15) !important;
            /* 一个更明显的淡蓝色背景 */

            border-radius: 8px;
            /* 圆角 */
            transform: scale(0.95);
            /* 轻微缩小以示区别 */
            box-shadow: none !important;
            /* 确保没有其他阴影覆盖边框 */
        }

        /* 确保容器有过渡效果，让动画更平滑 */
        .emoji-item-container {
            position: relative;
            transition: all 0.2s ease-in-out;
        }

        /* === 新增：美化App的动画控制 === */

        /* 默认状态：美化页完全透明，并且无法交互 */
        #beautify-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
            /* 默认在下层 */
        }

        /* 当 phone-frame 拥有 .show-beautify 类名时 */
        .phone-frame.show-beautify #home-screen {
            opacity: 0;
            pointer-events: none;
            z-index: 1;
        }

        .phone-frame.show-beautify #beautify-screen {
            opacity: 1;
            pointer-events: auto;
            z-index: 2;
            /* 美化页浮上来 */
        }
        /* === 新增：更换图标界面的动画控制 === */

/* 默认状态：更换图标页完全透明，并且无法交互 */
#icon-settings-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1; /* 默认在下层 */
}

/* 当 phone-frame 拥有 .show-icon-settings 类名时 */
.phone-frame.show-icon-settings #beautify-screen {
    opacity: 0; /* 隐藏美化界面 */
    pointer-events: none;
    z-index: 2;
}

.phone-frame.show-icon-settings #icon-settings-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 3; /* 更换图标页浮上来，层级要比美化页更高 */
}
/* === 新增：图标更换列表的样式 === */
.icon-setting-item {
    display: flex;
    align-items: center;
    width: 90%;
    margin: 0 auto 15px auto; /* 上下15px间距，左右自动居中 */
    padding: 10px;
    background-color: #f7f7f7;
    border-radius: 12px;
}

.icon-preview {
    width: 50px;
    height: 50px;
    border-radius: 12px;
    margin-right: 15px;
    object-fit: cover;
    flex-shrink: 0; /* 防止图标被压缩 */
}

.icon-details {
    display: flex;
    flex-direction: column;
    gap: 8px;
    flex-grow: 1; /* 占据所有剩余空间 */
    min-width: 0; /* 防止内容溢出时破坏布局 */
}

.app-name-setting {
    font-size: 16px;
    font-weight: 500;
    color: #111;
}

.icon-url-input {
    width: 100%;
    padding: 8px;
    border: 1px solid #dcdcdc;
    border-radius: 8px;
    font-size: 12px;
    background-color: #fff;
    box-sizing: border-box; /* 确保padding不会撑大宽度 */
}

/* === 新增：更换时钟界面的动画控制 === */

/* 默认状态：时钟设置页完全透明，且无法交互 */
#clock-settings-screen {
    opacity: 0;
    pointer-events: none;
    z-index: 1; /* 默认在下层 */
}

/* 当 .phone-frame 拥有 .show-clock-settings 类名时 */
.phone-frame.show-clock-settings #beautify-screen {
    opacity: 0; /* 隐藏美化界面 */
    pointer-events: none;
    z-index: 3;
}

.phone-frame.show-clock-settings #clock-settings-screen {
    opacity: 1;
    pointer-events: auto;
    z-index: 4; /* 层级比图标更换页更高 */
}

/* === 新增：时钟高斯模糊背景效果 === */
.clock.clock-blur-enabled {
    /* 1. 半透明背景色，这是模糊效果能看到东西的前提 */
    background-color: rgba(255, 255, 255, 0.15); 
    
    /* 2. 核心：高斯模糊效果 */
    -webkit-backdrop-filter: blur(15px); /* 兼容 Safari */
    backdrop-filter: blur(15px);
    
    /* 3. 美化样式，让它看起来像个圆角卡片 */
    padding: 5px 20px;
    border-radius: 25px;
    
    /* 4. （可选）添加一点边框和阴影增加质感 */
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
}

/* === 新增：回到底部按钮的样式 === */
#scroll-to-bottom-btn {
    /* 定位和尺寸 */
    position: absolute;
    right: 20px;
    bottom: 90px; /* 定位在输入框上方 */
    width: 25px;
    height: 25px;
    z-index: 30; /* 确保在消息之上 */

    /* 视觉样式 */
    background-color: white;
    border-radius: 50%; /* 圆形 */
    border: none;
    cursor: pointer;
    
    /* 阴影和发光效果，增强立体感 */
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15), 
                0 0 20px rgba(0, 122, 255, 0.1);

    /* 内部SVG居中 */
    display: flex;
    justify-content: center;
    align-items: center;

    /* 隐藏/显示动画效果 */
    opacity: 0;
    visibility: hidden;
    transform: translateY(15px);
    transition: all 0.25s ease-out;
}

/* 当按钮需要显示时，JS会为其添加这个类 */
#scroll-to-bottom-btn.visible {
    opacity: 1;
    visibility: visible;
    transform: translateY(0);
}
    </style>

    <style id="custom-bubble-styles"></style>

</head>

<body>

    <div class="phone-frame">
        <div id="dynamic-island" class="dynamic-island">
            <div class="island-collapsed-content">
                <div class="collapsed-music-info">
                    <svg class="music-icon-collapsed" width="16" height="16" viewBox="0 0 24 24" fill="none"
                        xmlns="http://www.w3.org/2000/svg">
                        <path d="M9 18V5l12-2v13" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></path>
                        <circle cx="6" cy="18" r="3" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></circle>
                        <circle cx="18" cy="16" r="3" stroke="white" stroke-width="2" stroke-linecap="round"
                            stroke-linejoin="round"></circle>
                    </svg>
                    <div class="title-scroller-window">
                        <span id="collapsed-song-title" class="collapsed-title"></span>
                    </div>
                </div>
            </div>
            <div class="island-expanded-content">

                <div class="expanded-header">

                    <div id="shared-listening-avatars" class="shared-avatars">

                        <div id="avatar-image-container"></div>

                        <div id="end-session-bubble" class="confirmation-bubble">
                            <span>结束一起听?</span>
                            <button id="end-listening-session-btn">结束</button>
                        </div>

                    </div>

                    <div class="song-details">
                        <div id="island-song-title" class="song-title">Pepas</div>
                        <div id="island-song-artist" class="song-artist">Farruko</div>
                    </div>

                    <button id="island-invite-button" class="island-action-button">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M8 11C10.7614 11 13 8.76142 13 6C13 3.23858 10.7614 1 8 1C5.23858 1 3 3.23858 3 6C3 8.76142 5.23858 11 8 11Z"
                                fill="white" />
                            <path
                                d="M0 21C0 16.5817 3.58172 13 8 13C12.4183 13 16 16.5817 16 21C16 22.1046 15.1046 23 14 23H2C0.895431 23 0 22.1046 0 21Z"
                                fill="white" />
                            <path
                                d="M17 13C18.6569 13 20 11.6569 20 10C20 8.34315 18.6569 7 17 7C15.3431 7 14 8.34315 14 10C14 11.6569 15.3431 13 17 13Z"
                                fill="white" />
                            <path d="M19 10V2L22 3" stroke="white" stroke-width="2" stroke-linecap="round"
                                stroke-linejoin="round" />
                        </svg>
                    </button>

                </div>

                <div class="progress-container">
                    <span id="progress-current-time">0:00</span>
                    <div class="progress-bar-wrapper">
                        <div id="progress-bar-fill" class="progress-bar-fill"></div>
                    </div>
                    <span id="progress-remaining-time">-0:00</span>
                </div>
                <div class="controls-container">
                    <button id="island-prev-btn" class="control-button">
                        <svg viewBox="0 0 24 24">
                            <path d="M6 6h2v12H6zm3.5 6l8.5 6V6z"></path>
                        </svg>
                    </button>
                    <button id="island-play-pause-btn" class="control-button play-pause">
                        <svg class="play-icon" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"></path>
                        </svg>
                        <svg class="pause-icon" viewBox="0 0 24 24">
                            <path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"></path>
                        </svg>
                    </button>
                    <button id="island-next-btn" class="control-button">
                        <svg viewBox="0 0 24 24">
                            <path d="M16 6h2v12h-2zm-4.5 6l-8.5 6V6z"></path>
                        </svg>
                    </button>
                </div>

            </div>
        </div>
        <div id="home-screen" class="screen active">

            <div class="content">

                <div class="header-content">
                    <div class="clock">
                        <span id="clock-hours">--</span>
                        <span>:</span>
                        <span id="clock-minutes">--</span>
                    </div>
                    <div class="motto-container">
                        <p id="motto" contenteditable="true">签名语录 (点击编辑)</p>
                    </div>
                </div>

                <div class="widget-placeholder" id="widgetContainer">
                    <span id="widgetText">Widgets（点击展示照片）</span>
                    <input type="file" id="imageUploader" accept="image/*" style="display: none;">
                </div>

                <div class="app-grid">
                    <div class="app-container" id="worldbook-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/50WLGSrN/Icon-pages-2.png" alt="世界书">
                        </div>
                        <span class="app-name">世界书</span>
                    </div>
                    <div class="app-container" id="messages-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/bJnwpTQR/app.png" alt="消息图标">
                        </div>
                        <span class="app-name">消息</span>
                    </div>

                    <div class="app-container" id="music-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/TPzWVh0C/Apple-Music-Icon.png" alt="音乐图标">
                        </div>
                        <span class="app-name">音乐</span>
                    </div>

                    <div class="app-container">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/RFhwRjxZ/image.png" alt="邮件图标">
                        </div>
                        <span class="app-name">邮件</span>
                    </div>

                    <div class="app-container" id="beautify-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/X7kVw6yR/ui.png" alt="美化">
                        </div>
                        <span class="app-name">美化</span>
                    </div>

                    <div class="app-container" id="settings-app-icon">
                        <div class="app-icon">
                            <img src="https://i.postimg.cc/y6g7qvVg/Settings.png" alt="设置图标">
                        </div>
                        <span class="app-name">设置</span>
                    </div>
                </div>

            </div>

        </div>
        <div id="settings-screen" class="screen">
            <div class="settings-header">
                <button id="back-button" class="header-text-button">返回</button>
                <h1>设置</h1>
                <button id="save-settings-button" class="header-text-button">保存</button>
            </div>
            <div class="settings-content">
                <div class="form-group">
                    <label for="api-url">URL</label>
                    <input type="text" id="api-url" class="form-input" placeholder="例如：https://api.openai.com">
                </div>

                <div class="form-group">
                    <label for="api-key">KEY</label>
                    <input type="password" id="api-key" class="form-input" placeholder="请输入您的 API Key">
                </div>

                <div class="form-group" style="display:flex; align-items:center; gap:15px;">
                    <button id="connect-api-button" class="form-button">连接测试</button>
                    <span id="api-connection-status" style="font-size: 14px; color: #8A8A8E;"></span>
                </div>

                <div class="form-group">
                    <label for="api-model">模型</label>
                    <select id="api-model" class="form-select" disabled>
                        <option value="" disabled selected>请先连接成功</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="temperature-slider" style="display:flex; justify-content:space-between;">
                        <span>温度</span>
                        <span id="temperature-value">1.0</span>
                    </label>
                    <input type="range" id="temperature-slider" class="form-slider" min="0" max="2" value="1"
                        step="0.1">
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>显示小组件</span>
                        <label class="switch">
                            <input type="checkbox" id="toggle-widget-visibility" checked>
                            <span class="slider round"></span>
                        </label>
                    </label>
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>启用全屏模式</span>
                        <label class="switch">
                            <input type="checkbox" id="toggle-frame-visibility">
                        </label>
                    </label>
                </div>
                <div class="form-group"> <label>主页壁纸</label>
                    <div class="wallpaper-controls">
                        <div id="wallpaper-preview"></div>
                        <div class="wallpaper-buttons">
                            <button id="upload-wallpaper-btn" class="form-button-secondary">选择图片</button>
                            <button id="reset-wallpaper-btn" class="form-button-secondary">恢复默认</button>
                        </div>
                    </div>
                </div>
                <!-- === 新增：全局字体更换功能 === -->
                <div class="form-group">
                    <label>全局字体</label>
                    <div class="wallpaper-buttons"> <!-- 复用壁纸按钮的布局 -->
                        <button id="change-font-btn" class="form-button-secondary">更换字体</button>
                        <button id="restore-font-btn" class="form-button-secondary">恢复默认</button>
                    </div>
                </div>
                <div class="form-group">
                    <label>数据管理</label>
                    <div class="wallpaper-buttons"> <button id="backup-data-btn"
                            class="form-button-secondary">备份</button>
                        <button id="import-data-btn" class="form-button-secondary">导入</button>
                    </div>
                </div>
                <input type="file" id="import-file-input" accept=".json" style="display: none;">

                <input type="file" id="wallpaper-upload-input" accept="image/*" style="display: none;">
            </div>

        </div>
        <div id="music-screen" class="screen">
            <div class="settings-header">
                <button id="music-back-button" class="header-text-button">返回</button>
                <h1>音乐</h1>
                <div class="header-actions">
                    <button id="playlist-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <div id="music-content" class="music-content">
                <button id="add-playlist-btn" class="add-playlist-button">新建歌单</button>
                <div class="scrollable-list-container">
                    <div id="playlist-grid" class="playlist-grid">
                    </div>
                </div>
            </div>

        </div>
        <div id="playlist-detail-screen" class="screen">
            <div class="settings-header playlist-header">
                <button id="playlist-back-button" class="header-text-button">返回</button>
                <h1 id="playlist-name-title">歌单名称</h1>
                <div class="header-actions">
                    <button id="edit-playlist-name-btn" class="header-button">编</button>
                    <button id="upload-cover-btn" class="header-button">封</button>
                    <button id="multi-select-btn" class="header-button">批</button>
                </div>
            </div>
            <div class="playlist-content">
                <button id="import-music-button" class="import-button">导入歌曲</button>
                <ul id="song-list" class="song-list">
                </ul>
            </div>
            <input type="file" id="music-file-input" accept=".mp3,.wav,.flac" multiple="" style="display: none;">
        </div>
        <div id="messages-screen" class="screen">
            <div class="settings-header">
                <button id="messages-back-button" class="header-text-button">返回</button>
                <h1>消息</h1>
                <div class="header-actions">
                    <button id="messages-add-btn" class="header-button">添加</button>
                    <button id="messages-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <!-- 这里是消息界面的内容区域，现在是空的 -->
            <div class="messages-content">
                <ul id="contact-list" class="contact-list">
                    <!-- 联系人列表项将通过 JS 动态添加到这里 -->
                </ul>
            </div>
        </div>

        <input type="file" id="cover-upload-input" accept="image/*" style="display: none;">
        <audio id="audio-player" style="display:none;"></audio>
        <!-- === 新增：添加联系人弹出层 (Modal) === -->
        <div id="add-contact-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">

                <!-- 1. 顶部滑块和关闭按钮 -->
                <div class="modal-header">
                    <div class="role-switcher">
                        <span class="switch-label active" data-form="ai">Char</span>
                        <label class="switch">
                            <input type="checkbox" id="role-switch-checkbox">
                            <span class="slider round"></span>
                        </label>
                        <span class="switch-label" data-form="user">User</span>
                    </div>
                    <button id="modal-close-btn" class="modal-close-button">&times;</button>
                </div>

                <!-- 2. AI信息表单 (默认显示) -->
                <div id="ai-form" class="role-form active">
                    <div class="avatar-uploader">
                        <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI" id="ai-avatar-preview"
                            class="avatar-preview">
                        <input type="file" id="ai-avatar-input" class="avatar-input" accept="image/*">
                        <label for="ai-avatar-input" class="avatar-upload-label">上传头像</label>
                    </div>
                    <input type="text" id="ai-name-input" class="form-input" placeholder="  角色名">
                    <textarea id="ai-persona-input" class="form-textarea" placeholder="人设输入区域..."></textarea>
                </div>

                <!-- 3. 用户信息表单 (默认隐藏) -->
                <div id="user-form" class="role-form">
                    <div class="avatar-uploader">
                        <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=User" id="user-avatar-preview"
                            class="avatar-preview">
                        <input type="file" id="user-avatar-input" class="avatar-input" accept="image/*">
                        <label for="user-avatar-input" class="avatar-upload-label">上传头像</label>
                    </div>
                    <input type="text" id="user-name-input" class="form-input" placeholder="  你的名字">
                    <textarea id="user-persona-input" class="form-textarea" placeholder="你的人设..."></textarea>
                </div>

                <!-- 4. 底部公共部分 -->
                <div class="modal-footer">
                    <div class="form-group-inline">
                        <label for="context-memory-input">上下文记忆:</label>
                        <input type="number" id="context-memory-input" class="form-input" value="10" min="0" max="100">
                    </div>
                    <button id="save-contact-btn" class="save-button">保存</button>
                </div>

            </div>
        </div>
        <!-- === 新增：聊天界面 === -->
        <div id="chat-screen" class="screen">
            <!-- 1. 悬浮顶栏 -->
            <div class="chat-header">
                <button id="chat-back-button" class="header-text-button">返回</button>
                <h1 id="chat-contact-name">角色名</h1>
                <div id="chat-header-actions-normal"
                    style="margin-left: auto; display: flex; align-items: center; gap: 10px;">
                    <button id="chat-search-button" class="header-text-button">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M14.4733 13.5267L12 11.0733C12.9601 9.87627 13.425 8.35686 13.2992 6.82753C13.1734 5.2982 12.4664 3.87519 11.3237 2.85109C10.1809 1.827 8.6892 1.27967 7.15528 1.32164C5.62136 1.36362 4.16181 1.99171 3.07676 3.07676C1.99171 4.16181 1.36362 5.62136 1.32164 7.15528C1.27967 8.6892 1.827 10.1809 2.85109 11.3237C3.87519 12.4664 5.2982 13.1734 6.82753 13.2992C8.35686 13.425 9.87627 12.9601 11.0733 12L13.5267 14.4533C13.5886 14.5158 13.6624 14.5654 13.7436 14.5993C13.8249 14.6331 13.912 14.6505 14 14.6505C14.088 14.6505 14.1751 14.6331 14.2564 14.5993C14.3376 14.5654 14.4114 14.5158 14.4733 14.4533C14.5935 14.329 14.6607 14.1629 14.6607 13.99C14.6607 13.8171 14.5935 13.651 14.4733 13.5267V13.5267ZM7.33333 12C6.41035 12 5.5081 11.7263 4.74067 11.2135C3.97324 10.7007 3.3751 9.97191 3.02189 9.11919C2.66868 8.26646 2.57627 7.32815 2.75633 6.42291C2.9364 5.51766 3.38085 4.68614 4.0335 4.0335C4.68614 3.38085 5.51766 2.9364 6.42291 2.75633C7.32815 2.57627 8.26646 2.66868 9.11919 3.02189C9.97191 3.3751 10.7007 3.97324 11.2135 4.74067C11.7263 5.5081 12 6.41035 12 7.33333C12 8.57101 11.5083 9.75799 10.6332 10.6332C9.75799 11.5083 8.57101 12 7.33333 12V12Z"
                                fill="#007AFF" />
                        </svg>
                    </button>
                    <button id="chat-settings-button" class="header-text-button">设置</button>
                </div>
                <div id="chat-header-actions-select" style="margin-left: auto; display: none;">
                    <button id="delete-messages-btn" class="header-text-button" style="color: #ff3b30;">删除</button>
                    <button id="cancel-selection-btn" class="header-text-button">取消</button>
                </div>
            </div>

            <!-- 2. 聊天消息容器 -->
            <div id="chat-messages-container" class="chat-messages-container">

                <!-- 聊天气泡将通过 JS 动态添加到这里 -->
            </div>

            <div id="more-features-panel" class="features-panel">
                <div class="features-grid">
                    <div class="feature-item" id="time-perception-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M15 11H13V7C13 6.73478 12.8946 6.48043 12.7071 6.29289C12.5196 6.10536 12.2652 6 12 6C11.7348 6 11.4804 6.10536 11.2929 6.29289C11.1054 6.48043 11 6.73478 11 7V12C11 12.2652 11.1054 12.5196 11.2929 12.7071C11.4804 12.8946 11.7348 13 12 13H15C15.2652 13 15.5196 12.8946 15.7071 12.7071C15.8946 12.5196 16 12.2652 16 12C16 11.7348 15.8946 11.4804 15.7071 11.2929C15.5196 11.1054 15.2652 11 15 11ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C21.9971 9.34874 20.9425 6.80691 19.0678 4.93219C17.1931 3.05746 14.6513 2.00295 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C19.9976 14.121 19.1539 16.1544 17.6542 17.6542C16.1544 19.1539 14.121 19.9976 12 20Z"
                                    fill="black" />
                            </svg>
                        </div>
                        <span class="feature-name">时间</span>
                    </div>
                    <div class="feature-item" id="transfer-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M12 1C9.82441 1 7.69767 1.64514 5.88873 2.85383C4.07979 4.06253 2.66989 5.78049 1.83733 7.79048C1.00477 9.80047 0.786929 12.0122 1.21137 14.146C1.6358 16.2798 2.68345 18.2398 4.22183 19.7782C5.76021 21.3166 7.72022 22.3642 9.85401 22.7886C11.9878 23.2131 14.1995 22.9952 16.2095 22.1627C18.2195 21.3301 19.9375 19.9202 21.1462 18.1113C22.3549 16.3023 23 14.1756 23 12C23 9.08262 21.8411 6.28473 19.7782 4.22183C17.7153 2.15893 14.9174 1 12 1ZM12 21C10.22 21 8.47992 20.4722 6.99987 19.4832C5.51983 18.4943 4.36628 17.0887 3.68509 15.4442C3.0039 13.7996 2.82567 11.99 3.17294 10.2442C3.5202 8.49836 4.37737 6.89471 5.63604 5.63604C6.89472 4.37737 8.49836 3.5202 10.2442 3.17293C11.99 2.82567 13.7996 3.0039 15.4442 3.68508C17.0887 4.36627 18.4943 5.51983 19.4832 6.99987C20.4722 8.47991 21 10.22 21 12C21 14.3869 20.0518 16.6761 18.364 18.364C16.6761 20.0518 14.387 21 12 21ZM14.83 6.45L12 10.7L9.17 6.45C9.09736 6.34007 9.0037 6.24559 8.89441 6.17198C8.78513 6.09836 8.66238 6.04707 8.53321 6.02105C8.40404 5.99503 8.271 5.9948 8.14174 6.02036C8.01248 6.04592 7.88955 6.09677 7.78 6.17C7.56079 6.31662 7.40838 6.5439 7.35593 6.80236C7.30349 7.06082 7.35527 7.32954 7.5 7.55L9.61 10.72H9C8.73479 10.72 8.48043 10.8254 8.2929 11.0129C8.10536 11.2004 8 11.4548 8 11.72C8 11.9852 8.10536 12.2396 8.2929 12.4271C8.48043 12.6146 8.73479 12.72 9 12.72H11L11.05 12.8V13.72H9C8.73479 13.72 8.48043 13.8254 8.2929 14.0129C8.10536 14.2004 8 14.4548 8 14.72C8 14.9852 8.10536 15.2396 8.2929 15.4271C8.48043 15.6146 8.73479 15.72 9 15.72H11V18C11 18.2652 11.1054 18.5196 11.2929 18.7071C11.4804 18.8946 11.7348 19 12 19C12.2652 19 12.5196 18.8946 12.7071 18.7071C12.8946 18.5196 13 18.2652 13 18V15.72H15C15.2652 15.72 15.5196 15.6146 15.7071 15.4271C15.8946 15.2396 16 14.9852 16 14.72C16 14.4548 15.8946 14.2004 15.7071 14.0129C15.5196 13.8254 15.2652 13.72 15 13.72H13V12.8L13.05 12.72H15C15.2652 12.72 15.5196 12.6146 15.7071 12.4271C15.8946 12.2396 16 11.9852 16 11.72C16 11.4548 15.8946 11.2004 15.7071 11.0129C15.5196 10.8254 15.2652 10.72 15 10.72H14.39L16.5 7.55C16.6447 7.32954 16.6965 7.06082 16.6441 6.80236C16.5916 6.5439 16.4392 6.31662 16.22 6.17C16.1105 6.09677 15.9875 6.04592 15.8583 6.02036C15.729 5.9948 15.596 5.99503 15.4668 6.02105C15.3376 6.04707 15.2149 6.09836 15.1056 6.17198C14.9963 6.24559 14.9027 6.34007 14.83 6.45Z"
                                    fill="black" />
                            </svg>

                        </div>
                        <span class="feature-name">转账</span>
                    </div>
                    <div class="feature-item" id="receipt-feature">
                        <div class="feature-icon">
                            <svg width="24" height="24" viewBox="0 0 24 24" fill="none"
                                xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M19 14C18.8726 13.9669 18.74 13.9593 18.6096 13.9777C18.4793 13.996 18.3539 14.0398 18.2405 14.1067C18.1272 14.1736 18.0282 14.2622 17.9492 14.3675C17.8701 14.4727 17.8126 14.5925 17.78 14.72C17.3976 16.2285 16.5234 17.5666 15.2956 18.5228C14.0677 19.479 12.5563 19.9988 11 20H5.41002L6.05002 19.37C6.23627 19.1826 6.34081 18.9292 6.34081 18.665C6.34081 18.4008 6.23627 18.1474 6.05002 17.96C5.06751 16.9816 4.39772 15.7334 4.1256 14.3737C3.85348 13.0141 3.9913 11.6043 4.52156 10.3231C5.05183 9.04185 5.95065 7.94699 7.10404 7.17733C8.25743 6.40768 9.61342 5.99791 11 6C11.2932 5.98479 11.5869 5.98479 11.88 6C12.1452 6.03183 12.4122 5.95699 12.6223 5.79196C12.8323 5.62693 12.9682 5.38522 13 5.12C13.0318 4.85478 12.957 4.58779 12.792 4.37775C12.6269 4.16771 12.3852 4.03183 12.12 4C11.7471 3.97484 11.3729 3.97484 11 4C9.30748 4.00556 7.65082 4.48828 6.2202 5.39274C4.78959 6.2972 3.64301 7.58673 2.91209 9.11332C2.18116 10.6399 1.89553 12.3417 2.08796 14.0232C2.2804 15.7048 2.94311 17.298 4.00002 18.62L2.29002 20.29C2.15126 20.4306 2.05726 20.6092 2.01989 20.8032C1.98252 20.9972 2.00344 21.1979 2.08002 21.38C2.15504 21.5626 2.28244 21.7189 2.44616 21.8293C2.60988 21.9396 2.80259 21.999 3.00002 22H11C12.9963 22.0013 14.9363 21.3388 16.5149 20.1169C18.0934 18.895 19.221 17.1829 19.72 15.25C19.7576 15.1206 19.7687 14.985 19.7526 14.8512C19.7365 14.7175 19.6936 14.5883 19.6263 14.4716C19.5591 14.3549 19.469 14.2529 19.3613 14.1719C19.2537 14.0908 19.1308 14.0324 19 14ZM21.71 7.26C21.6171 7.16627 21.5065 7.09188 21.3846 7.04111C21.2627 6.99034 21.132 6.9642 21 6.9642C20.868 6.9642 20.7373 6.99034 20.6154 7.04111C20.4936 7.09188 20.383 7.16627 20.29 7.26L19 8.59V3C19 2.73478 18.8947 2.48043 18.7071 2.29289C18.5196 2.10536 18.2652 2 18 2C17.7348 2 17.4804 2.10536 17.2929 2.29289C17.1054 2.48043 17 2.73478 17 3V8.59L15.71 7.29C15.6168 7.19676 15.5061 7.1228 15.3843 7.07234C15.2624 7.02188 15.1319 6.99591 15 6.99591C14.8682 6.99591 14.7376 7.02188 14.6158 7.07234C14.4939 7.1228 14.3833 7.19676 14.29 7.29C14.1968 7.38324 14.1228 7.49393 14.0724 7.61575C14.0219 7.73757 13.9959 7.86814 13.9959 8C13.9959 8.13186 14.0219 8.26243 14.0724 8.38425C14.1228 8.50607 14.1968 8.61676 14.29 8.71L17.29 11.71C17.3851 11.801 17.4973 11.8724 17.62 11.92C17.7397 11.9729 17.8691 12.0002 18 12.0002C18.1309 12.0002 18.2603 11.9729 18.38 11.92C18.5028 11.8724 18.6149 11.801 18.71 11.71L21.71 8.71C21.8037 8.61704 21.8781 8.50644 21.9289 8.38458C21.9797 8.26272 22.0058 8.13201 22.0058 8C22.0058 7.86799 21.9797 7.73728 21.9289 7.61542C21.8781 7.49356 21.8037 7.38296 21.71 7.29V7.26Z" />
                            </svg>
                        </div>
                        <span class="feature-name">接收</span>
                    </div>

                </div>

            </div>

            <!-- 3. 底部输入区域 -->
            <div class="chat-input-area">
                <!-- 用下面的 SVG 替换掉原来的加号按钮 -->
                <button id="chat-add-attachment-button" class="chat-action-button">
                    <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path
                            d="M12 4.5V11.25L15 12L12.0762 19.5H12V13.4766L9 12.7266L11.9238 4.5H12ZM13.5 3H10.8662L10.5117 3.99609L7.58496 12.2256L7.03418 13.7812L8.63672 14.1826L10.5 14.6484V21H13.1016L13.4736 20.0449L16.3975 12.5449L17.0156 10.957L13.5 10.0781V3Z"
                            fill="black" />
                    </svg>
                </button>

                <div class="chat-input-wrapper">
                    <input type="text" id="chat-message-input" placeholder="输入消息...">

                    <button id="chat-emoji-button" class="chat-action-button">
                        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M14.66 13.56L10.47 15.06C10.2498 15.1399 10.0646 15.2945 9.94677 15.497C9.82893 15.6994 9.78589 15.9368 9.82517 16.1678C9.86446 16.3987 9.98356 16.6085 10.1617 16.7606C10.3399 16.9127 10.5658 16.9974 10.8 17C10.916 16.9999 11.031 16.9796 11.14 16.94L15.34 15.44C15.467 15.3981 15.5842 15.3312 15.6849 15.2431C15.7855 15.1551 15.8675 15.0478 15.926 14.9276C15.9844 14.8073 16.0182 14.6766 16.0252 14.5431C16.0323 14.4095 16.0125 14.276 15.967 14.1502C15.9215 14.0245 15.8513 13.9092 15.7604 13.8111C15.6696 13.7129 15.56 13.634 15.4382 13.579C15.3163 13.524 15.1847 13.4939 15.051 13.4907C14.9174 13.4874 14.7844 13.511 14.66 13.56ZM10.66 8.56C10.4726 8.37375 10.2192 8.26921 9.955 8.26921C9.69082 8.26921 9.43737 8.37375 9.25 8.56C9.15704 8.65373 9.04644 8.72812 8.92458 8.77889C8.80272 8.82966 8.67202 8.8558 8.54 8.8558C8.40799 8.8558 8.27729 8.82966 8.15543 8.77889C8.03357 8.72812 7.92297 8.65373 7.83 8.56C7.64264 8.37375 7.38919 8.26921 7.125 8.26921C6.86082 8.26921 6.60737 8.37375 6.42 8.56C6.32628 8.65296 6.25188 8.76356 6.20111 8.88542C6.15034 9.00728 6.12421 9.13799 6.12421 9.27C6.12421 9.40201 6.15034 9.53272 6.20111 9.65458C6.25188 9.77644 6.32628 9.88704 6.42 9.98C6.98251 10.5418 7.745 10.8574 8.54 10.8574C9.33501 10.8574 10.0975 10.5418 10.66 9.98C10.7542 9.88405 10.8282 9.77008 10.8773 9.64491C10.9265 9.51974 10.9499 9.38593 10.9462 9.25149C10.9425 9.11706 10.9117 8.98476 10.8556 8.86251C10.7996 8.74026 10.7194 8.63057 10.62 8.54L10.66 8.56ZM17.66 8.56C17.4726 8.37375 17.2192 8.26921 16.955 8.26921C16.6908 8.26921 16.4374 8.37375 16.25 8.56C16.157 8.65373 16.0464 8.72812 15.9246 8.77889C15.8027 8.82966 15.672 8.8558 15.54 8.8558C15.408 8.8558 15.2773 8.82966 15.1554 8.77889C15.0336 8.72812 14.923 8.65373 14.83 8.56C14.6426 8.37375 14.3892 8.26921 14.125 8.26921C13.8608 8.26921 13.6074 8.37375 13.42 8.56C13.3263 8.65296 13.2519 8.76356 13.2011 8.88542C13.1503 9.00728 13.1242 9.13799 13.1242 9.27C13.1242 9.40201 13.1503 9.53272 13.2011 9.65458C13.2519 9.77644 13.3263 9.88704 13.42 9.98C13.9825 10.5418 14.745 10.8574 15.54 10.8574C16.335 10.8574 17.0975 10.5418 17.66 9.98C17.7542 9.88405 17.8282 9.77008 17.8773 9.64491C17.9265 9.51974 17.9499 9.38593 17.9462 9.25149C17.9425 9.11706 17.9117 8.98476 17.8556 8.86251C17.7996 8.74026 17.7194 8.63057 17.62 8.54L17.66 8.56ZM12 2C10.0222 2 8.08879 2.58649 6.4443 3.6853C4.79981 4.78412 3.51809 6.3459 2.76121 8.17317C2.00433 10.0004 1.8063 12.0111 2.19215 13.9509C2.578 15.8907 3.53041 17.6725 4.92894 19.0711C6.32746 20.4696 8.10929 21.422 10.0491 21.8079C11.9889 22.1937 13.9996 21.9957 15.8268 21.2388C17.6541 20.4819 19.2159 19.2002 20.3147 17.5557C21.4135 15.9112 22 13.9778 22 12C22 10.6868 21.7413 9.38642 21.2388 8.17317C20.7363 6.95991 19.9997 5.85752 19.0711 4.92893C18.1425 4.00035 17.0401 3.26375 15.8268 2.7612C14.6136 2.25866 13.3132 2 12 2ZM12 20C10.4178 20 8.87104 19.5308 7.55544 18.6518C6.23985 17.7727 5.21447 16.5233 4.60897 15.0615C4.00347 13.5997 3.84504 11.9911 4.15372 10.4393C4.4624 8.88743 5.22433 7.46197 6.34315 6.34315C7.46197 5.22433 8.88743 4.4624 10.4393 4.15372C11.9911 3.84504 13.5997 4.00346 15.0615 4.60896C16.5233 5.21447 17.7727 6.23984 18.6518 7.55544C19.5308 8.87103 20 10.4177 20 12C20 14.1217 19.1572 16.1566 17.6569 17.6569C16.1566 19.1571 14.1217 20 12 20Z"
                                fill="black" />
                        </svg>
                    </button>
                </div>
                <button id="chat-send-button" class="chat-action-button">
                    <svg t="1755525428099" class="icon" viewBox="0 0 1024 1024" version="1.1"
                        xmlns="http://www.w3.org/2000/svg" p-id="6198">
                        <path
                            d="M815.744 74.752a587.52 587.52 0 0 0-84.864 5.632 958.976 958.976 0 0 0-63.616 10.496 1597.44 1597.44 0 0 0-138.752 33.6A2104.384 2104.384 0 0 0 258.112 221.44a1344.576 1344.576 0 0 0-55.616 26.496 652.672 652.672 0 0 0-67.84 39.104 313.6 313.6 0 0 0-17.664 12.8 201.984 201.984 0 0 0-22.016 19.968 110.08 110.08 0 0 0-11.2 14.72 58.368 58.368 0 0 0-8.768 38.272 85.12 85.12 0 0 0 4.736 21.12 92.928 92.928 0 0 0 12.992 24.64 142.08 142.08 0 0 0 29.376 29.12 198.4 198.4 0 0 0 23.04 15.232 379.52 379.52 0 0 0 40 19.2c9.344 3.968 19.008 7.552 28.8 10.944a723.456 723.456 0 0 0 60.16 18.112c10.24 2.688 20.352 5.12 30.4 7.552 20.096 4.736 39.808 8.96 57.984 12.736l24.896 5.12c12.736 2.56 24.192 4.992 34.112 7.104 9.92 2.176 18.304 4.032 24.96 5.888a200.192 200.192 0 0 1 22.912 8.128c1.088 0.512 1.728 0.96 2.624 1.472 1.088 0.64 2.432 1.28 3.2 1.92l0.576 0.32a22.912 22.912 0 0 1 5.952 6.784 44.352 44.352 0 0 1 3.2 6.4c1.024 2.624 2.176 5.952 3.328 9.984 1.152 4.032 2.368 8.768 3.648 14.464 5.824 26.752 11.392 51.968 16.704 75.648 5.312 23.68 10.432 45.824 15.36 66.368 4.992 20.544 9.856 39.68 14.656 56.96a975.616 975.616 0 0 0 14.4 47.168 453.568 453.568 0 0 0 15.744 38.848c2.816 5.952 5.76 11.52 8.832 16.768a114.816 114.816 0 0 0 28.224 33.28 80.128 80.128 0 0 0 14.912 8.96 71.232 71.232 0 0 0 32.384 6.272 49.024 49.024 0 0 0 15.872-3.84 69.12 69.12 0 0 0 16.768-9.536 104.128 104.128 0 0 0 14.016-12.352c4.48-4.608 8.896-9.6 13.12-14.912a459.072 459.072 0 0 0 39.04-59.776 882.24 882.24 0 0 0 26.56-50.816 1349.12 1349.12 0 0 0 27.008-58.496 1841.28 1841.28 0 0 0 39.744-98.048 2304.128 2304.128 0 0 0 67.52-210.112 1653.568 1653.568 0 0 0 22.848-100.224 816 816 0 0 0 12.352-89.28c0.704-9.152 1.152-18.048 1.28-26.624a340.608 340.608 0 0 0-0.384-24.704 239.104 239.104 0 0 0-4.224-33.536 148.8 148.8 0 0 0-10.88-31.104 87.104 87.104 0 0 0-12.288-17.408 77.44 77.44 0 0 0-16.832-13.76 100.224 100.224 0 0 0-20.032-9.472 168.064 168.064 0 0 0-21.76-5.888 223.488 223.488 0 0 0-22.464-3.2 315.52 315.52 0 0 0-24.64-1.408z m-1.344 64c7.04 0.128 13.696 0.384 19.84 1.024 6.528 0.64 12.16 1.472 16.896 2.496 4.736 0.96 8.64 2.048 11.84 3.2 3.2 1.152 5.76 2.432 7.68 3.52 1.92 1.152 3.2 2.112 3.968 3.008a19.584 19.584 0 0 1 2.752 4.352 48.192 48.192 0 0 1 3.136 8 166.72 166.72 0 0 1 4.48 29.632 406.336 406.336 0 0 1-3.2 68.352 744.32 744.32 0 0 1-9.024 57.024 1181.888 1181.888 0 0 1-13.632 62.72 1617.664 1617.664 0 0 1-27.52 100.672 2179.712 2179.712 0 0 1-84.608 231.04 1579.008 1579.008 0 0 1-38.528 81.088 807.552 807.552 0 0 1-24.256 42.752 398.464 398.464 0 0 1-21.376 30.976 130.944 130.944 0 0 1-8.832 10.048 58.432 58.432 0 0 1-6.528 5.824l-0.256 0.256a16 16 0 0 1-3.712-2.56 40.832 40.832 0 0 1-5.376-5.952 83.2 83.2 0 0 1-5.76-8.448 148.672 148.672 0 0 1-6.016-11.392 383.744 383.744 0 0 1-19.52-52.864c-2.176-7.36-4.48-15.104-6.72-23.296a1712.64 1712.64 0 0 1-13.888-54.208c-4.8-19.84-9.728-41.472-14.976-64.896-5.312-23.424-10.88-48.704-16.896-75.84a296.128 296.128 0 0 0-4.48-18.048 163.392 163.392 0 0 0-9.408-24.96c-1.28-2.624-2.688-5.12-4.224-7.68l-0.64-0.96 127.04-126.976a32.192 32.192 0 0 0 6.976-10.688 31.36 31.36 0 0 0 0-24 32 32 0 0 0-12.032-14.72 32.192 32.192 0 0 0-23.68-4.608 31.36 31.36 0 0 0-16.576 8.704L484.096 494.72l-2.944-1.28a273.6 273.6 0 0 0-17.408-5.376 516.48 516.48 0 0 0-28.864-7.04 2955.072 2955.072 0 0 0-36.608-7.616l-22.912-4.608a2065.92 2065.92 0 0 1-84.992-19.456 888.192 888.192 0 0 1-55.744-16.768 466.624 466.624 0 0 1-25.152-9.536 314.56 314.56 0 0 1-22.208-10.112 201.472 201.472 0 0 1-19.008-10.88 120 120 0 0 1-18.368-14.848 57.28 57.28 0 0 1-6.912-8.64 25.472 25.472 0 0 1-4.096-11.264l1.024-1.472a60.16 60.16 0 0 1 6.08-6.656 136.32 136.32 0 0 1 10.368-8.96 393.984 393.984 0 0 1 52.032-33.024 799.68 799.68 0 0 1 48.64-24.768 1277.44 1277.44 0 0 1 56.448-25.216 1997.952 1997.952 0 0 1 95.488-36.992 2169.216 2169.216 0 0 1 102.656-34.048 2061.632 2061.632 0 0 1 102.656-28.096 1537.408 1537.408 0 0 1 64.832-14.272 1111.232 1111.232 0 0 1 60.16-9.856 705.728 705.728 0 0 1 52.608-4.864 371.2 371.2 0 0 1 22.528-0.256z"
                            fill="#ffffff" p-id="6199"></path>
                    </svg>
                </button>
            </div>

            <div id="emoji-panel">
                <div class="emoji-panel-header">
                    <button id="add-emoji-btn" class="panel-header-button">添加</button>
                    <button id="multiselect-emoji-btn" class="panel-header-button">多选</button>
                </div>
                <div id="emoji-grid-container">
                </div>

                
            </div>

        </div>

        <button id="scroll-to-bottom-btn">
            <svg width="27" height="31" viewBox="0 0 27 31" fill="none" xmlns="http://www.w3.org/2000/svg">
                <g clip-path="url(#clip0_201_5911)">
                <path d="M24.9049 13.6817L26.191 14.9678C26.7356 15.5123 26.7356 16.3929 26.191 16.9316L14.9349 28.1935C14.3904 28.7381 13.5098 28.7381 12.9711 28.1935L1.7092 16.9316C1.16464 16.3871 1.16464 15.5065 1.7092 14.9678L2.99528 13.6817C3.54562 13.1313 4.44356 13.1429 4.98232 13.7049L11.6329 20.6856V4.03611C11.6329 3.26562 12.2527 2.64575 13.0232 2.64575H14.877C15.6475 2.64575 16.2674 3.26562 16.2674 4.03611V20.6856L22.9179 13.7049C23.4567 13.1371 24.3546 13.1255 24.9049 13.6817Z" fill="black"/>
                </g>
                <defs>
                <clipPath id="clip0_201_5911">
                <rect width="25.9533" height="29.6609" fill="white" transform="translate(0.973877 0.791992)"/>
                </clipPath>
                </defs>
            </svg>
        </button>

        <div id="worldbook-screen" class="screen">
            <div class="settings-header">
                <button id="worldbook-back-button" class="header-text-button">返回</button>
                <h1>世界书</h1>
                <div class="header-actions">
                    <button id="worldbook-multiselect-btn" class="header-button">多选</button>
                </div>
            </div>
            <div class="music-content">
                <button id="add-worldbook-btn" class="add-playlist-button">新建世界书</button>
                <div class="scrollable-list-container">
                    <div id="worldbook-list" class="contact-list" style="margin-top: 20px;">
                    </div>
                </div>
            </div>
        </div>

        


        <!-- === 新增：聊天设置弹出层 (Modal) === -->
        <div id="chat-settings-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content large"> <!-- 使用 .large 类让对话框更宽敞 -->

                <!-- 顶部关闭按钮 -->
                <div class="modal-header">
                    <h2>聊天设置</h2>
                    <button id="chat-settings-close-btn" class="modal-close-button">&times;</button>
                </div>

                <!-- 对话框主体内容 -->
                <div class="modal-body">

                    <!-- 左侧：角色编辑区域 (复用之前的结构) -->
                    <div class="settings-column">
                        <h4>角色信息</h4>
                        <div class="role-switcher">
                            <span class="switch-label active" data-form="ai-settings">Char</span>
                            <label class="switch">
                                <input type="checkbox" id="role-switch-checkbox-settings">
                                <span class="slider round"></span>
                            </label>
                            <span class="switch-label" data-form="user-settings">User</span>
                        </div>

                        <div id="ai-form-settings" class="role-form active">
                            <div class="avatar-uploader">
                                <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI"
                                    id="ai-avatar-preview-settings" class="avatar-preview">
                                <input type="file" id="ai-avatar-input-settings" class="avatar-input" accept="image/*">
                                <label for="ai-avatar-input-settings" class="avatar-upload-label">上传头像</label>
                            </div>
                            <input type="text" id="ai-name-input-settings" class="form-input" placeholder="角色名">
                            <textarea id="ai-persona-input-settings" class="form-textarea"
                                placeholder="人设..."></textarea>
                        </div>

                        <div id="user-form-settings" class="role-form">
                            <div class="avatar-uploader">
                                <img src="https://placehold.co/100x100/EFEFEF/AAAAAA?text=User"
                                    id="user-avatar-preview-settings" class="avatar-preview">
                                <input type="file" id="user-avatar-input-settings" class="avatar-input"
                                    accept="image/*">
                                <label for="user-avatar-input-settings" class="avatar-upload-label">上传头像</label>
                            </div>
                            <input type="text" id="user-name-input-settings" class="form-input" placeholder="你的名字">
                            <textarea id="user-persona-input-settings" class="form-textarea"
                                placeholder="你的人设..."></textarea>
                        </div>
                        <div class="form-group-inline">
                            <label>上下文记忆:</label>
                            <input type="number" id="context-memory-input-settings" class="form-input" value="10"
                                min="0" max="100">
                        </div>

                        <div class="form-group"> <label>关联世界书 (可多选):</label>
                            <div id="worldbook-multiselect-container" class="multiselect-container">
                            </div>
                        </div>
                    </div>

                    <!-- 右侧：新增的聊天自定义区域 -->
                    <div class="settings-column">
                        <h4>个性化</h4>
                        <div class="form-group">
                            <label>自定义气泡样式 (CSS)</label>
                            <textarea id="bubble-css-input" class="form-textarea code"
                                placeholder=".user-bubble {&#10;  background-color: #007AFF;&#10;}&#10;.ai-bubble {&#10;  background-color: #E5E5EA;&#10;}"></textarea>
                            <button id="restore-bubble-css-btn" class="form-button-secondary small">恢复默认</button>
                        </div>
                        <div class="form-group">
                            <label style="display: flex; justify-content: space-between; align-items: center;">
                                <span>显示聊天头像</span>
                                <label class="switch">
                                    <input type="checkbox" id="show-avatars-toggle" checked>
                                    <span class="slider round"></span>
                                </label>
                            </label>
                            <div class="form-group-inline" style="margin-top: 8px;">
                                <label for="avatar-radius-input">头像圆角值:</label>
                                <input type="text" id="avatar-radius-input" class="form-input" value="50%"
                                    placeholder="e.g., 50% or 8px">
                            </div>
                        </div>

                        <div class="form-group">
                            <label>聊天背景</label>
                            <div class="wallpaper-buttons">
                                <button id="upload-chat-bg-btn" class="form-button-secondary">选择图片</button>
                                <button id="reset-chat-bg-btn" class="form-button-secondary">恢复默认</button>
                            </div>
                        </div>

                        <div class="form-group danger-zone">
                            <label>危险操作</label>
                            <button id="clear-history-btn" class="danger-button">清除聊天记录</button>
                        </div>
                    </div>

                </div>

                <!-- 底部保存按钮 -->
                <div class="modal-footer">
                    <button id="save-chat-settings-btn" class="save-button">保存设置</button>
                </div>

                <!-- 隐藏的文件上传输入框 -->
                <input type="file" id="chat-bg-upload-input" accept="image/*" style="display: none;">
            </div>
        </div>

        <!-- 隐藏的文件选择框，用于导入字体 -->
        <input type="file" id="font-import-input" accept=".ttf,.otf" style="display: none;">

        <div id="add-worldbook-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>新建世界书</h2>
                    <button id="worldbook-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="gap: 15px; padding: 15px 0;">
                    <div class="form-group">
                        <label for="worldbook-name-input">世界书名称</label>
                        <input type="text" id="worldbook-name-input" class="form-input" placeholder="例如：艾泽拉斯编年史">
                    </div>
                    <div class="form-group">
                        <label for="worldbook-content-input">世界书内容</label>
                        <textarea id="worldbook-content-input" class="form-textarea" placeholder="输入关于这个世界的设定..."
                            style="height: 200px;"></textarea>
                    </div>
                </div>
                <div class="modal-footer">
                    <button id="save-worldbook-btn" class="save-button">保存</button>
                </div>
            </div>
        </div>

        <div id="beautify-screen" class="screen">
            <div class="settings-header">
                <button id="beautify-back-button" class="header-text-button">返回</button>
                <h1>美化</h1>
            </div>

            <div class="settings-content">
                <button id="change-icon-button" class="form-button-secondary" style="width: 90%;">更换图标</button>
                <button id="change-clock-button" class="form-button-secondary" style="width: 90%;">更换时钟</button>
            </div>
            
        </div>

        <div id="icon-settings-screen" class="screen">
            <div class="settings-header">
                <button id="icon-settings-back-button" class="header-text-button">返回</button>
                <h1>更换图标</h1>
            </div>
            
            <div class="settings-content">
                <div id="icon-list-container" style="width: 100%; padding-top: 70px;">
                    </div>
            </div>
        </div>

        <div id="clock-settings-screen" class="screen">
            <div class="settings-header">
                <button id="clock-settings-back-button" class="header-text-button">返回</button>
                <h1>更换时钟</h1>
            </div>
        
            <div class="settings-content" style="padding-top: 90px;">
                <div class="form-group">
                    <label for="clock-color-input">时钟颜色 (输入颜色代码或点右侧色块)</label>
                    <div style="display: flex; align-items: center; width: 93%; gap: 10px;">
                        <input type="text" id="clock-color-input" class="form-input" placeholder="#000000">
                        <input type="color" id="clock-color-picker" style="height: 40px; width: 50px; border-radius: 8px; border: 1px solid #d1d1d6; cursor: pointer;">
                    </div>
                </div>
                <div class="form-group">
                    <label style="display: flex; justify-content: space-between; align-items: center;">
                        <span>启用高斯模糊背景</span>
                        <label class="switch">
                            <input type="checkbox" id="clock-blur-toggle">
                            <span class="slider round"></span>
                        </label>
                    </label>
                </div>
            </div>
        </div>


        <div id="transfer-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>发起转账</h2>
                    <button id="transfer-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="gap: 15px; padding: 15px 0;">
                    <div class="form-group">
                        <label for="transfer-amount-input">转账金额 (¥)</label>
                        <input type="number" id="transfer-amount-input" class="form-input" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <label for="transfer-remark-input">备注</label>
                        <input type="text" id="transfer-remark-input" class="form-input" placeholder="最多20个字">
                    </div>
                </div>
                <div class="modal-footer" style="align-items: center;">
                    <button id="confirm-transfer-btn" class="save-button">确认转账</button>
                </div>
            </div>


        </div>
        <div id="search-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content large">
                <div class="modal-header">
                    <h2>搜索聊天记录</h2>
                    <button id="search-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" style="padding: 15px;">
                    <input type="search" id="search-input" class="form-input" placeholder="输入关键词..."
                        style="width: 100%; box-sizing: border-box; margin-bottom: 15px;">
                    <div id="search-results-container">
                    </div>
                </div>
            </div>
        </div>
        <div id="invite-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>一起听</h2>
                    <button id="invite-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body" id="invite-contact-list-container">
                </div>
            </div>
        </div>

        <div id="add-emoji-modal" class="modal-overlay" style="display: none;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>批量添加表情</h2>
                    <button id="emoji-modal-close-btn" class="modal-close-button">&times;</button>
                </div>
                <div class="modal-body">
                    <p style="font-size: 13px; color: #555; margin-top: 0;">请输入一个或多个图片URL，用英文逗号 (,) 分隔。</p>
                    <textarea id="emoji-urls-textarea" class="form-textarea"
                        placeholder="https://.../image1.gif, https://.../image2.png" style="height: 150px;"></textarea>
                </div>
                <div class="modal-footer">
                    <button id="save-emoji-btn" class="save-button">确认添加</button>
                </div>
            </div>
        </div>
        

    </div>

    <script>

        // =================================================
        // 第一部分：所有 const 和 let 变量声明，必须放在最前面
        // =================================================
        // === 新增：获取时钟高斯模糊开关和时钟容器 ===
const clockBlurToggle = document.getElementById('clock-blur-toggle');
const clockContainer = document.querySelector('.clock');
// === 新增：获取时钟设置相关元素 ===
const changeClockButton = document.getElementById('change-clock-button');
const clockSettingsScreen = document.getElementById('clock-settings-screen');
const clockSettingsBackButton = document.getElementById('clock-settings-back-button');
const clockColorInput = document.getElementById('clock-color-input');
const clockColorPicker = document.getElementById('clock-color-picker');
const clockElements = document.querySelectorAll('.clock span');
        // === 新增：获取美化App相关元素 ===
        const beautifyAppIcon = document.getElementById('beautify-app-icon');
        const beautifyScreen = document.getElementById('beautify-screen');
        const beautifyBackButton = document.getElementById('beautify-back-button');
        // === 新增：获取更换图标界面相关元素 ===
const changeIconButton = document.getElementById('change-icon-button');
const iconSettingsScreen = document.getElementById('icon-settings-screen');
const iconSettingsBackButton = document.getElementById('icon-settings-back-button');

        const multiselectEmojiBtn = document.getElementById('multiselect-emoji-btn');
        let isEmojiDeleteMode = false; // 新增：用于跟踪表情包是否处于删除模式
        // === 新增：页面导航的脚本 ===
        const audioPlayer = document.getElementById('audio-player');
        const wallpaperUploadInput = document.getElementById('wallpaper-upload-input');
        const phoneFrame = document.querySelector('.phone-frame');
        const homeScreen = document.getElementById('home-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const settingsAppIcon = document.getElementById('settings-app-icon');
        const backButton = document.getElementById('back-button');
        const saveSettingsButton = document.getElementById('save-settings-button');
        const musicAppIcon = document.getElementById('music-app-icon');
        const musicScreen = document.getElementById('music-screen');
        const musicBackButton = document.getElementById('music-back-button');

        // === 新增：歌单多选功能所需元素 ===
        const playlistMultiselectBtn = document.getElementById('playlist-multiselect-btn');
        let isPlaylistDeleteMode = false; // 用于跟踪是否处于删除模式

        const messagesAppIcon = document.getElementById('messages-app-icon');
        const messagesScreen = document.getElementById('messages-screen');
        const messagesBackButton = document.getElementById('messages-back-button');


        // === 新增：添加联系人弹出层所需的所有元素 ===
        const addContactModal = document.getElementById('add-contact-modal');
        const messagesAddBtn = document.getElementById('messages-add-btn');
        const modalCloseBtn = document.getElementById('modal-close-btn');
        const roleSwitchCheckbox = document.getElementById('role-switch-checkbox');
        const switchLabels = document.querySelectorAll('.switch-label');
        const aiForm = document.getElementById('ai-form');
        const userForm = document.getElementById('user-form');
        const contactList = document.getElementById('contact-list');

        // 表单内部元素
        const aiAvatarPreview = document.getElementById('ai-avatar-preview');
        const aiAvatarInput = document.getElementById('ai-avatar-input');
        const aiNameInput = document.getElementById('ai-name-input');
        const aiPersonaInput = document.getElementById('ai-persona-input');

        const userAvatarPreview = document.getElementById('user-avatar-preview');
        const userAvatarInput = document.getElementById('user-avatar-input');
        const userNameInput = document.getElementById('user-name-input');
        const userPersonaInput = document.getElementById('user-persona-input');

        const contextMemoryInput = document.getElementById('context-memory-input');
        const saveContactBtn = document.getElementById('save-contact-btn');
        const messagesMultiselectBtn = document.getElementById('messages-multiselect-btn');
        const loadMoreMessagesBtn = document.getElementById('load-more-messages-btn');

        // === 新增：聊天界面所需的所有元素 ===
        const chatScreen = document.getElementById('chat-screen');
        const chatBackButton = document.getElementById('chat-back-button');
        const chatContactName = document.getElementById('chat-contact-name');
        const chatMessagesContainer = document.getElementById('chat-messages-container');
        const chatMessageInput = document.getElementById('chat-message-input');
        const chatSendButton = document.getElementById('chat-send-button');
        let isAiReplying = false;


        // === 新增：聊天设置弹出层所需的所有元素 ===
        const chatSettingsModal = document.getElementById('chat-settings-modal');
        const chatSettingsButton = document.getElementById('chat-settings-button');
        const chatSettingsCloseBtn = document.getElementById('chat-settings-close-btn');
        const saveChatSettingsBtn = document.getElementById('save-chat-settings-btn');

        // 角色编辑 (在设置弹窗内)
        const roleSwitchCheckboxSettings = document.getElementById('role-switch-checkbox-settings');
        const aiFormSettings = document.getElementById('ai-form-settings');
        const userFormSettings = document.getElementById('user-form-settings');
        const aiAvatarPreviewSettings = document.getElementById('ai-avatar-preview-settings');
        const aiAvatarInputSettings = document.getElementById('ai-avatar-input-settings');
        const aiNameInputSettings = document.getElementById('ai-name-input-settings');
        const aiPersonaInputSettings = document.getElementById('ai-persona-input-settings');
        const userAvatarPreviewSettings = document.getElementById('user-avatar-preview-settings');
        const userAvatarInputSettings = document.getElementById('user-avatar-input-settings');
        const userNameInputSettings = document.getElementById('user-name-input-settings');
        const userPersonaInputSettings = document.getElementById('user-persona-input-settings');
        const contextMemoryInputSettings = document.getElementById('context-memory-input-settings');

        // 个性化设置
        const bubbleCssInput = document.getElementById('bubble-css-input');
        const restoreBubbleCssBtn = document.getElementById('restore-bubble-css-btn');
        const uploadChatBgBtn = document.getElementById('upload-chat-bg-btn');
        const resetChatBgBtn = document.getElementById('reset-chat-bg-btn');
        const chatBgUploadInput = document.getElementById('chat-bg-upload-input');
        const clearHistoryBtn = document.getElementById('clear-history-btn');
        const customBubbleStyles = document.getElementById('custom-bubble-styles');

        const fullscreenToggle = document.getElementById('toggle-frame-visibility');
        const bodyElement = document.body; // 获取 body 元素


        const worldbookAppIcon = document.getElementById('worldbook-app-icon');
        const worldbookBackButton = document.getElementById('worldbook-back-button');
        const addWorldbookBtn = document.getElementById('add-worldbook-btn');
        const addWorldbookModal = document.getElementById('add-worldbook-modal');
        const worldbookModalCloseBtn = document.getElementById('worldbook-modal-close-btn');
        const saveWorldbookBtn = document.getElementById('save-worldbook-btn');
        const worldbookNameInput = document.getElementById('worldbook-name-input');
        const worldbookContentInput = document.getElementById('worldbook-content-input');
        const worldbookListContainer = document.getElementById('worldbook-list');
        const worldbookMultiselectBtn = document.getElementById('worldbook-multiselect-btn');
        let isWorldbookDeleteMode = false; // 删除模式的状态
        let currentEditingBookId = null; // null 表示新建，有值表示编辑

        const showAvatarsToggle = document.getElementById('show-avatars-toggle');
        const avatarRadiusInput = document.getElementById('avatar-radius-input');
        // === 新增：备份与恢复功能所需元素 ===
        const backupDataBtn = document.getElementById('backup-data-btn');
        const importDataBtn = document.getElementById('import-data-btn');
        const importFileInput = document.getElementById('import-file-input');
        // === 新增：字体更换功能所需元素 ===
        const customFontStyle = document.getElementById('custom-font-style');
        const changeFontBtn = document.getElementById('change-font-btn');
        const restoreFontBtn = document.getElementById('restore-font-btn');
        const fontImportInput = document.getElementById('font-import-input');
        const worldbookSelectSettings = document.getElementById('worldbook-select-settings');


        // 1. 获取需要的元素
        const chatEmojiButton = document.getElementById('chat-emoji-button');
        const chatScreenForPanel = document.getElementById('chat-screen'); // chat-screen 作为父容器
        const chatMessagesForPanel = document.getElementById('chat-messages-container'); // 消息容器



        // === 新增：API 设置所需的元素 ===

        const apiUrlInput = document.getElementById('api-url');
        const apiKeyInput = document.getElementById('api-key');
        const connectButton = document.getElementById('connect-api-button');
        const apiStatusSpan = document.getElementById('api-connection-status');
        const modelSelect = document.getElementById('api-model');
        const saveApiButton = document.getElementById('save-settings-button'); // 这个按钮是设置页顶部的保存按钮
        const tempSlider = document.getElementById('temperature-slider');
        const tempValueSpan = document.getElementById('temperature-value');
        // === 1. 获取所有需要操作的HTML元素 ===
        // 时钟元素
        const clockHoursElem = document.getElementById('clock-hours');
        const clockMinutesElem = document.getElementById('clock-minutes');
        // 语录元素
        const mottoElem = document.getElementById('motto');
        // 小组件元素
        const widgetContainer = document.getElementById('widgetContainer');
        const widgetVisibilityToggle = document.getElementById('toggle-widget-visibility');
        const imageUploader = document.getElementById('imageUploader');
        const widgetText = document.getElementById('widgetText');
        // === 新增：壁纸功能所需的元素 ===
        const wallpaperPreview = document.getElementById('wallpaper-preview');
        const resetWallpaperBtn = document.getElementById('reset-wallpaper-btn');
        const uploadWallpaperBtn = document.getElementById('upload-wallpaper-btn');
        const defaultBodyBg = '#f0f2f5'; // 一个柔和的淡粉色


        // --- 新增：灵动岛相关元素和状态管理 ---
        // Add this line with the other element declarations
        const collapsedSongTitle = document.getElementById('collapsed-song-title');
        const dynamicIsland = document.getElementById('dynamic-island');
        const islandSongTitle = document.getElementById('island-song-title');
        const islandSongArtist = document.getElementById('island-song-artist');
        const islandPlayPauseBtn = document.getElementById('island-play-pause-btn');
        const islandPrevBtn = document.getElementById('island-prev-btn');
        const islandNextBtn = document.getElementById('island-next-btn');
        const progressCurrentTime = document.getElementById('progress-current-time');
        const progressRemainingTime = document.getElementById('progress-remaining-time');
        const progressBarFill = document.getElementById('progress-bar-fill');


        const addPlaylistBtn = document.getElementById('add-playlist-btn');
        const playlistGrid = document.getElementById('playlist-grid');
        const playlistDetailScreen = document.getElementById('playlist-detail-screen');
        const playlistBackButton = document.getElementById('playlist-back-button');
        const playlistNameTitle = document.getElementById('playlist-name-title');
        const importMusicButton = document.getElementById('import-music-button');
        const musicFileInput = document.getElementById('music-file-input');
        const songList = document.getElementById('song-list');
        const uploadCoverBtn = document.getElementById('upload-cover-btn');
        const multiSelectBtn = document.getElementById('multi-select-btn');
        const coverUploadInput = document.getElementById('cover-upload-input');

        // === 新增：歌单名称编辑所需元素 ===
        const editPlaylistNameBtn = document.getElementById('edit-playlist-name-btn');




        // === 新增：表情包功能的核心JS逻辑 ===

        // 1. 获取所有新添加的HTML元素
        const addEmojiBtn = document.getElementById('add-emoji-btn');
        const addEmojiModal = document.getElementById('add-emoji-modal');
        const emojiModalCloseBtn = document.getElementById('emoji-modal-close-btn');
        const saveEmojiBtn = document.getElementById('save-emoji-btn');
        const emojiUrlInput = document.getElementById('emoji-urls-textarea');
        const emojiGridContainer = document.getElementById('emoji-grid-container');

// === 新增：处理图标URL输入的核心逻辑 ===

const iconListContainer = document.getElementById('icon-list-container');
// === 新增：AI可用表情包的描述与URL映射 ===
const stickerMap = new Map([
    ['可爱动漫小狗趴在手机旁边等消息', 'https://i.postimg.cc/TY5RfBw3/1755713422890.gif'],
    ['求求了', 'https://i.postimg.cc/SKRY4knt/1755749657526.jpg'],
    ['喝AD钙', 'https://i.postimg.cc/9XP7hxxT/1755749847793.gif'],
    ['无语', 'https://i.postimg.cc/5N0NRpDf/1755749922509.jpg'],
    ['摸摸小猫头', 'https://i.postimg.cc/rsTgpDX9/1755749920816.jpg'],
    ['你脑子进水了', 'https://i.postimg.cc/NF1X5D7y/1755750006013.jpg'],
    ['汗流浃背', 'https://i.postimg.cc/nh0DjTg5/1755750086388.gif'],
    ['小猫wink', 'https://i.postimg.cc/JndxNMFf/1755750145576.gif'],
    ['emo了', 'https://i.postimg.cc/Bn7764C1/006-APo-FYly8gtkjwbge8oj30hs0eut9p.jpg'],
    ['太美味了', 'https://i.postimg.cc/7Y5fdyLZ/47ee5e40ea31b7fe1e3b34de080f0568.jpg'],
    ['已老实', 'https://i.postimg.cc/zBDfksM5/3048e89d841be9618f1b4730867ab67a.jpg'],
    ['过去软弱的我已经死了！现在是更软弱的我', 'https://i.postimg.cc/RFbvLNKQ/ddbd366ce245f3e8f4ea9b119435c751.jpg'],
    ['哦？是吗？', 'https://i.postimg.cc/XJXbq4mZ/12207db77b0c4a7db2dc4e44aca91055.jpg'],
    ['这张卡你拿着，密码是0，余额也是', 'https://i.postimg.cc/KzVygCh0/5691afc7baf80877eb46bf4b155b6fa3.jpg'],
    ['强忍泪水', 'https://i.postimg.cc/qgHV1nRn/c43e7347b4bd240c7852e055dd12ac37.jpg'],
    ['想不想我', 'https://i.postimg.cc/sD5vs45k/b3ab2f36fa5013dc22112b639efbb199.jpg'],
    ['你是个二百五！', 'https://i.postimg.cc/J43494Lm/005-XSXm-Ngy1gvw48nmbc0j304602d0sl.jpg'],
    ['有一点骚', 'https://i.postimg.cc/Z5VY57nM/006-CXr-Ejly1gtavg3d53fg308s08swex.gif'],
    ['能好好爱我吗，emo了。', 'https://i.postimg.cc/gjWbD8rh/ceeb653ely8gtrqmsutcfj20hs0hsq44.jpg'],
    ['你单身！！', 'https://i.postimg.cc/gk7NbdqS/006-APo-FYly8gt9twjaud5j30hs0hs3zb.jpg'],
    ['恶心', 'https://i.postimg.cc/dQx8L6kD/005-L0-HLIgy1hcls43b180j30gn0gndgs.jpg'],
    ['无语了家人们', 'https://i.postimg.cc/tT75Y4bV/005-L0-HLIgy1hcls42ketdj30ar0ar74h.jpg'],
    ['哥帅不帅?', 'https://i.postimg.cc/mkyt47n3/005-L0-HLIgy1hcls3yaxl8j30k00k0wev.jpg'],
    ['好困呀', 'https://i.postimg.cc/9XnkPsNh/005-L0-HLIgy1hcls41ni15j30qv0pvdh3.jpg']
]);

        // === IndexedDB 帮助函数 START ===

        // === IndexedDB 帮助函数 (已彻底修复) ===
        const dbHelper = {
            db: null,
            dbName: 'phoneDataDB',

            // 1. 初始化数据库
            async init() {
                return new Promise((resolve, reject) => {
                    if (this.db) {
                        resolve();
                        return;
                    }
                    // 数据库版本提升到 2，以确保 onupgradeneeded 事件被触发，从而创建新的数据仓库
                    const request = indexedDB.open(this.dbName, 4);

                    request.onerror = (event) => {
                        console.error("数据库打开失败:", event);
                        reject("数据库打开失败");
                    };

                    request.onsuccess = (event) => {
                        this.db = event.target.result;
                        resolve();
                    };

                    // 第一次创建或版本更新时调用
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        const stores = ['settingsStore', 'messageContacts', 'musicPlaylists', 'worldBooks', 'emojiStore'];
                        stores.forEach(storeName => {
                            if (!db.objectStoreNames.contains(storeName)) {
                                // 【核心修正】我们为 emojiStore 指定 url 作为 key，其他保持不变
                                if (storeName === 'emojiStore') {
                                    db.createObjectStore(storeName, { keyPath: 'url' });
                                } else {
                                    db.createObjectStore(storeName, { keyPath: 'id' });
                                }
                            }
                        });
                    };
                });
            },

            // 2. 保存/更新数据 (已修复：接受 storeName 参数)
            async saveData(storeName, id, value) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put({ id, value }); // 数据结构为 {id: 'key', value: 'the_data'}

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`数据保存到 ${storeName} 失败: ` + event.target.error);
                });
            },

            // 3. 读取数据 (已修复：接受 storeName 参数)
            async loadData(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.get(id);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`从 ${storeName} 读取数据失败: ` + event.target.error);
                });
            },

            // 4. 删除数据 (已修复：接受 storeName 参数)
            async deleteData(storeName, id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.delete(id);

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`从 ${storeName} 删除数据失败: ` + event.target.error);
                });
            },
            async getAllDataFromStore(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readonly');
                    const store = transaction.objectStore(storeName);
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = (event) => reject(`从 ${storeName} 读取所有数据失败: ` + event.target.error);
                });
            },

            // 6. (新增) 清空一个存储
            async clearStore(storeName) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.clear();

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`清空 ${storeName} 失败: ` + event.target.error);
                });
            },
            async updateRecord(storeName, record) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction([storeName], 'readwrite');
                    const store = transaction.objectStore(storeName);
                    const request = store.put(record); // 直接放入更新后的完整对象

                    request.onsuccess = () => resolve();
                    request.onerror = (event) => reject(`更新 ${storeName} 中的记录失败: ` + event.target.error);
                });
            }

        };



        // === IndexedDB 帮助函数 END ===


        // 2. 为表情按钮绑定点击事件
        chatEmojiButton.addEventListener('click', () => {
            // 3. 切换父容器的激活类名，CSS会自动处理剩下的动画
            chatScreenForPanel.classList.toggle('emoji-panel-active');

            // 4. (优化体验) 每次打开或关闭面板后，都尝试将消息列表滚动到底部
            //    这样可以确保用户能看到最新的消息
            setTimeout(() => {
                chatMessagesForPanel.scrollTop = chatMessagesForPanel.scrollHeight;
            }, 300); // 延迟时间与CSS动画时间一致
        });



        let playbackState = {
            playlist: [],       // 当前播放的整个歌单
            currentIndex: -1,   // 当前歌曲在歌单中的索引
            currentSong: null,  // 当前歌曲的对象
            isPlaying: false
        };
        // === 2. 时钟功能 ===
        function updateClock() {
            const now = new Date();
            // 使用padStart确保数字总是两位数 (例如 01, 02)
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');

            clockHoursElem.textContent = hours;
            clockMinutesElem.textContent = minutes;
        }

        // === 3. 数据存储功能 (使用 localStorage) ===

        // 功能A: 加载已保存的数据 (页面打开时执行)
        // 将 function loadData() 修改为 async function loadData()
        async function loadData() {

            // 加载语录
            // 原代码: const savedMotto = localStorage.getItem('savedMotto');
            const mottoData = await dbHelper.loadData('settingsStore', 'savedMotto');
            if (mottoData) {
                mottoElem.textContent = mottoData.value;
            }

            // 加载小组件图片
            // 原代码: const savedWidgetImage = localStorage.getItem('savedWidgetImage');
            const widgetImageData = await dbHelper.loadData('settingsStore', 'savedWidgetImage');
            if (widgetImageData) {
                widgetContainer.style.backgroundImage = `url('${widgetImageData.value}')`;
                widgetText.style.display = 'none';
                widgetContainer.style.border = 'none';
            }

            // 加载API设置
            // 原代码: const savedApiSettings = localStorage.getItem('apiSettings');
            const apiSettingsData = await dbHelper.loadData('settingsStore', 'apiSettings');
            if (apiSettingsData) {
                // IndexedDB可以直接存对象，所以无需JSON.parse
                const settings = apiSettingsData.value;
                apiUrlInput.value = settings.url || '';
                apiKeyInput.value = settings.key || '';
                if (settings.model) {
                    modelSelect.innerHTML = `<option value="${settings.model}">${settings.model}</option>`;
                    modelSelect.value = settings.model;
                    modelSelect.disabled = false;
                }
                tempSlider.value = settings.temperature || 1.0;
                updateSliderProgress();
            }

            // 加载壁纸
            // 原代码: const savedWallpaper = localStorage.getItem('homeWallpaper') || defaultBodyBg;
            const wallpaperData = await dbHelper.loadData('settingsStore', 'homeWallpaper');
            const savedWallpaper = wallpaperData ? wallpaperData.value : defaultBodyBg;
            homeScreen.style.backgroundImage = savedWallpaper;
            wallpaperPreview.style.backgroundImage = savedWallpaper;

            // 加载小组件可见性
            // 原代码: const isWidgetVisible = localStorage.getItem('isWidgetVisible') !== 'false';
            const widgetVisibleData = await dbHelper.loadData('settingsStore', 'isWidgetVisible');
            // 如果没存过 (null/undefined)，则默认为 true
            const isWidgetVisible = widgetVisibleData ? widgetVisibleData.value : true;
            widgetVisibilityToggle.checked = isWidgetVisible;
            if (!isWidgetVisible) {
                widgetContainer.classList.add('widget-hidden');
            }
            const fullscreenData = await dbHelper.loadData('settingsStore', 'isFullscreenEnabled');
            // 默认是关闭的 (false)
            const isFullscreenEnabled = fullscreenData ? fullscreenData.value : false;
            fullscreenToggle.checked = isFullscreenEnabled;
            applyFullscreenMode(isFullscreenEnabled); // 页面加载时应用一次
        }

        // 功能B: 保存语录 (当编辑完成时触发)
        // "blur"事件表示元素失去焦点，即用户编辑完成
        mottoElem.addEventListener('blur', async () => {
            // 原代码: localStorage.setItem('savedMotto', mottoElem.textContent);
            await dbHelper.saveData('settingsStore', 'savedMotto', mottoElem.textContent);
        });

        // === 4. 小组件图片上传功能 (已集成保存功能) ===
        widgetContainer.addEventListener('click', () => {
            imageUploader.click();
        });

        imageUploader.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const imageDataUrl = e.target.result;
                    widgetContainer.style.backgroundImage = `url('${imageDataUrl}')`;
                    widgetText.style.display = 'none';
                    widgetContainer.style.border = 'none';
                    await dbHelper.saveData('settingsStore', 'savedWidgetImage', imageDataUrl);
                };
                reader.readAsDataURL(file);
            }
        });




        // === 5. 初始化页面 ===
        async function initializeApp() {
            try {
                // 首先初始化数据库
                await dbHelper.init();
                // 数据库准备好后，再加载数据
                await loadData();

                await loadCustomIcons();
                await loadClockColor();
                await loadClockBlurSetting();

                await loadPlaylists();

                await loadContacts();

                await loadAndRenderEmojis();

                // 时钟功能不受影响
                updateClock();
                setInterval(updateClock, 30000);

                const fontData = await dbHelper.loadData('settingsStore', 'customFont');
                if (fontData && fontData.value) {
                    applyCustomFont(fontData.value);
                }

            } catch (error) {
                console.error("应用初始化失败:", error);
                alert("无法加载数据，请刷新页面重试。");
            }
        }

        // 将这段新代码添加到你的JS脚本区域
        // 用这个新版本替换旧的 emojiGridContainer.addEventListener
        // 用这个新版本替换旧的 emojiGridContainer 的点击事件
        // 用这个新版本，替换掉你原来的 emojiGridContainer.addEventListener('click', ...)
        emojiGridContainer.addEventListener('click', (event) => {

            // 判断当前是否处于“多选删除模式”
            if (isEmojiDeleteMode) {
                const container = event.target.closest('.emoji-item-container');
                if (container) {
                    const checkbox = container.querySelector('.emoji-checkbox');
                    if (checkbox) {
                        // 如果用户点击的不是复选框本身，我们才需要手动帮他勾选
                        // 这样可以避免用户直接点复选框时，我们的代码和他操作冲突
                        if (event.target !== checkbox) {
                            checkbox.checked = !checkbox.checked;
                        }

                        // === 核心修复在这里 ===
                        // 根据复选框的最新状态，来决定是否给容器添加 'selected' 类
                        container.classList.toggle('selected', checkbox.checked);
                    }
                }
                return; // 结束函数，不执行发送逻辑
            }

            // 如果不是删除模式，执行正常的“发送”逻辑
            if (event.target.tagName === 'IMG' && event.target.classList.contains('emoji-item')) {
                const imgElement = event.target;
                const remarkElement = imgElement.nextElementSibling;

                const remark = remarkElement ? remarkElement.textContent.trim() : "表情";
                const url = imgElement.dataset.url;

                if (url) {
                    const stickerMessage = {
                        type: 'sticker',
                        text: `[表情包：${remark}]`,
                        url: url
                    };

                    sendMessage(stickerMessage);

                    chatScreenForPanel.classList.remove('emoji-panel-active');
                }
            }
        });
        // 运行初始化函数
        initializeApp();




        // 点击“设置”App图标：给父容器添加类名来触发动画
        settingsAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-settings');
        });
// === 新增：时钟设置界面的导航事件 ===

// 点击“更换时钟”按钮：从美化页进入时钟设置页
changeClockButton.addEventListener('click', () => {
    phoneFrame.classList.add('show-clock-settings');
});

// 点击时钟设置页的“返回”按钮：返回到美化页
clockSettingsBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-clock-settings');
});
        // === 新增：更换图标界面的导航事件 ===

// 点击“更换图标”按钮：从美化页进入图标设置页
changeIconButton.addEventListener('click', () => {
    phoneFrame.classList.add('show-icon-settings');
    renderIconSettings(); 
});

// 点击图标设置页的“返回”按钮：返回到美化页
iconSettingsBackButton.addEventListener('click', () => {
    phoneFrame.classList.remove('show-icon-settings');
});

        // === 新增：美化App的导航事件 ===

        // 点击“美化”App图标：给父容器添加类名来触发动画
        beautifyAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-beautify');
        });

        // 点击美化App的“返回”按钮：从父容器移除类名来触发返回动画
        beautifyBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-beautify');
        });

        // 点击“返回”按钮：从父容器移除类名来触发返回动画
        backButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-settings');
        });

        // === 新增：连接按钮的事件监听 ===
        // === 新增：连接按钮的事件监听 (已增强错误提示) ===
        connectButton.addEventListener('click', async () => {
            const apiUrl = apiUrlInput.value.trim();
            const apiKey = apiKeyInput.value.trim();

            if (!apiUrl || !apiKey) {
                apiStatusSpan.textContent = "URL和Key不能为空";
                return;
            }

            connectButton.textContent = "连接中...";
            connectButton.disabled = true;
            apiStatusSpan.textContent = "";

            try {
                const response = await fetch(`${apiUrl}/v1/models`, {
                    headers: { 'Authorization': `Bearer ${apiKey}` }
                });

                // --- 变化从这里开始 ---

                if (!response.ok) {
                    // 如果响应状态不是 2xx，我们根据状态码抛出具体的错误
                    throw new Error(`HTTP Error: ${response.status}`);
                }

                // 如果请求成功...
                const data = await response.json();
                modelSelect.innerHTML = '<option value="" disabled selected>选择一个模型</option>';
                data.data.forEach(model => {
                    modelSelect.innerHTML += `<option value="${model.id}">${model.id}</option>`;
                });
                modelSelect.disabled = false;
                apiStatusSpan.textContent = "✓ 连接成功";
                apiStatusSpan.style.color = "green";

            } catch (error) {
                console.error("API 连接失败:", error); // 在控制台保留详细错误供开发者查看

                // 根据错误类型，显示不同的用户提示
                if (error instanceof TypeError && error.message.includes('Failed to fetch')) {
                    // 这是最常见的网络或CORS错误
                    apiStatusSpan.textContent = "✗ 网络错误或跨域问题";
                    apiStatusSpan.style.color = "red";
                    alert("连接失败！最常见的原因是：\n\n1. API服务器未开启CORS跨域许可。\n2. 浏览器插件拦截了请求 (如广告拦截器)。\n3. 您的网络无法访问该URL地址。\n\n请按 F12 打开开发者工具，在“控制台(Console)”中查看详细的错误信息。");
                } else if (error.message.startsWith('HTTP Error:')) {
                    // 这是我们自己抛出的HTTP状态码错误
                    const status = error.message.split(':')[1].trim();
                    let tip = `(状态码: ${status})`;
                    if (status === '401') {
                        tip = "✗ 认证失败 (401)，请检查您的API Key是否正确。";
                    } else if (status === '404') {
                        tip = "✗ 未找到 (404)，请检查您的URL地址是否正确。";
                    } else if (status >= 500) {
                        tip = `✗ 服务器错误 (${status})，API服务可能暂时不可用。`;
                    } else {
                        tip = `✗ 请求失败 ${tip}，请检查API文档。`;
                    }
                    apiStatusSpan.textContent = tip;
                    apiStatusSpan.style.color = "red";
                } else {
                    // 其他未知错误
                    apiStatusSpan.textContent = "✗ 未知错误，请查看控制台";
                    apiStatusSpan.style.color = "red";
                }

                modelSelect.innerHTML = '<option value="" disabled selected>连接失败</option>';

                // --- 变化在这里结束 ---

            } finally {
                connectButton.textContent = "连接测试";
                connectButton.disabled = false;
            }
        });

        // === 新增：温度滑块的事件监听 ===
        function updateSliderProgress() {
            const value = parseFloat(tempSlider.value);
            const percentage = (value / 2) * 100; // 因为最大值是2
            tempSlider.style.setProperty('--progress-percent', `${percentage}%`);
            tempValueSpan.textContent = value.toFixed(1);
        }
        tempSlider.addEventListener('input', updateSliderProgress);
        // (新) 保存设置按钮的点击事件
        // (新) 保存设置按钮的点击事件 (已修复)
        saveSettingsButton.addEventListener('click', async () => {

            // --- 关键修复在这里 ---
            // 从各个输入框中读取当前的值，并组装成一个对象
            const apiSettings = {
                url: apiUrlInput.value.trim(),
                key: apiKeyInput.value.trim(),
                model: modelSelect.value,
                temperature: tempSlider.value
            };

            // 将组装好的、包含最新设置的对象存入数据库
            await dbHelper.saveData('settingsStore', 'apiSettings', apiSettings);

            alert('设置已保存！');
            phoneFrame.classList.remove('show-settings');
        });
        // === 新增：壁纸更换的事件监听 ===

        // 点击“选择图片”按钮，实际是触发隐藏的 input
        uploadWallpaperBtn.addEventListener('click', () => {
            wallpaperUploadInput.click();
        });

        // 当用户选择了图片文件后
        wallpaperUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = async (e) => { // 改为 async
                    const imageDataUrl = `url(${e.target.result})`;
                    homeScreen.style.backgroundImage = imageDataUrl;
                    wallpaperPreview.style.backgroundImage = imageDataUrl;

                    // 原代码: localStorage.setItem('homeWallpaper', imageDataUrl);
                    await dbHelper.saveData('settingsStore', 'homeWallpaper', imageDataUrl);
                };
                reader.readAsDataURL(file);
            }
        });

        // 点击“恢复默认”按钮
        resetWallpaperBtn.addEventListener('click', async () => {
            // 1. 恢复主屏幕和预览区的壁纸为默认
            homeScreen.style.backgroundImage = 'none'; // 清除背景图片
            homeScreen.style.backgroundColor = defaultBodyBg; // 设置背景颜色
            wallpaperPreview.style.backgroundImage = 'none'; // 清除预览图
            wallpaperPreview.style.backgroundColor = defaultBodyBg; // 设置预览区背景色

            // 2. 从本地存储中移除自定义壁纸记录
            await dbHelper.deleteData('settingsStore', 'homeWallpaper');
        });
        widgetVisibilityToggle.addEventListener('change', async () => { // 改为 async
            if (widgetVisibilityToggle.checked) {
                widgetContainer.classList.remove('widget-hidden');
                await dbHelper.saveData('settingsStore', 'isWidgetVisible', true);
            } else {
                widgetContainer.classList.add('widget-hidden');
                await dbHelper.saveData('settingsStore', 'isWidgetVisible', false);
            }
        });

        // === 新增：世界书 App 的导航事件 ===
        worldbookAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-worldbook');
            loadAndRenderWorldBooks();
        });

        worldbookBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-worldbook');
        });

        // === 新增：消息 App 的导航事件 ===

        // 点击“消息”App图标：给父容器添加类名来触发动画
        messagesAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-messages');
        });

        // 点击消息App的“返回”按钮：从父容器移除类名来触发返回动画
        messagesBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-messages');
        });
        // === 新增：音乐App的导航事件 ===

        // 点击“音乐”App图标：给父容器添加类名来触发动画
        musicAppIcon.addEventListener('click', () => {
            phoneFrame.classList.add('show-music');
        });

        // 点击音乐App的“返回”按钮：从父容器移除类名来触发返回动画
        musicBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-music');
        });
        // === 音乐 App 歌单功能 ===

        // 1. 获取需要的 HTML 元素


        // 3. 定义一个函数，用于创建歌单卡片的 HTML 结构
        // === 这是 createPlaylistCard 函数的唯一正确版本 ===
        // 它创建卡片、异步更新歌曲数量，并为卡片绑定了正确的点击事件

        // === 更新 createPlaylistCard (增加复选框) ===
        function createPlaylistCard(name, playlistData) {
            const card = document.createElement('div');
            card.className = 'playlist-card';
            card.dataset.playlistName = name;

            // --- 新增：在卡片内部添加复选框 ---
            card.innerHTML = `
        <input type="checkbox" class="playlist-checkbox">
        <div class="playlist-cover"></div>
        <div class="playlist-name"></div>
        <div class="playlist-count"></div>
    `;

            // 获取刚刚创建的元素并填充内容
            const coverDiv = card.querySelector('.playlist-cover');
            if (playlistData && playlistData.coverUrl) {
                coverDiv.style.backgroundImage = `url(${playlistData.coverUrl})`;
            }

            card.querySelector('.playlist-name').textContent = name;

            const songCount = (playlistData && Array.isArray(playlistData.songs)) ? playlistData.songs.length : 0;
            card.querySelector('.playlist-count').textContent = `${songCount} 首歌曲`;

            playlistGrid.appendChild(card);

            card.addEventListener('click', (event) => {
                // 如果是删除模式，并且点击的不是复选框，则模拟点击复选框
                if (isPlaylistDeleteMode && event.target.type !== 'checkbox') {
                    const checkbox = card.querySelector('.playlist-checkbox');
                    checkbox.checked = !checkbox.checked;
                } else if (!isPlaylistDeleteMode) {
                    // 正常模式下才进入详情页
                    openPlaylistDetailView(name);
                }
            });
        }
        /// === 修改：从数据库加载并显示歌单（适配新数据结构） ===
        async function loadPlaylists() {
            const playlistData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
            if (playlistData && typeof playlistData.value === 'object') {
                const playlists = playlistData.value;
                playlistGrid.innerHTML = '';
                Object.keys(playlists).forEach(name => {
                    // 将整个歌单对象传入，而不仅仅是名字
                    createPlaylistCard(name, playlists[name]);
                });
            }
        }
        // === 新增：歌单详情页的全部交互逻辑 ===

        // 1. 获取新页面的所有元素


        let isDeleteMode = false; // 用于跟踪是否处于删除模式

        let currentOpenPlaylist = null; // 存储当前打开的歌单的名称


        // 3. 打开歌单详情页的函数
        // === 修改：打开歌单详情页的函数（增加健壮性检查） ===
        // === 替换为修复版：正确显示歌曲列表 ===
        async function openPlaylistDetailView(playlistName) {
            currentOpenPlaylist = playlistName;
            playlistNameTitle.textContent = playlistName;
            songList.innerHTML = '';

            const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');

            // --- 关键修复在这里 ---
            // 检查新数据结构中的 .songs 属性是否是一个有效的数组
            if (allPlaylistsData && allPlaylistsData.value && allPlaylistsData.value[playlistName] && Array.isArray(allPlaylistsData.value[playlistName].songs)) {
                // 从 .songs 属性中获取歌曲列表
                const songs = allPlaylistsData.value[playlistName].songs;
                songs.forEach(song => {
                    appendSongToList(song);
                });
            } else {
                // 这段代码现在只会在数据确实为空或损坏时触发
                console.warn(`歌单 "${playlistName}" 的歌曲数据不是一个有效的数组，或者为空。`);
            }

            // 显示详情页
            phoneFrame.classList.add('show-playlist-detail');
        }

        // 4. 关闭歌单详情页
        playlistBackButton.addEventListener('click', () => {
            phoneFrame.classList.remove('show-playlist-detail');
            currentOpenPlaylist = null; // 清理当前歌单记录
        });

        // 5. "导入歌曲" 按钮的点击事件
        importMusicButton.addEventListener('click', () => {
            musicFileInput.click(); // 触发隐藏的文件选择框
        });

        // 6. 文件选择框检测到变化的事件
        // === 替换为修复版：向数据库存储文件对象本身 ===
        musicFileInput.addEventListener('change', async (event) => {
            const files = event.target.files;
            if (!files.length || !currentOpenPlaylist) return;

            try {
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                let allPlaylists = allPlaylistsData.value;

                for (const file of files) {
                    let title = file.name.replace(/\.(mp3|wav|flac)$/i, '');
                    let artist = '未知艺术家';
                    if (/\s*-\s*/.test(title)) {
                        [title, artist] = title.split(/\s*-\s*/).map(s => s.trim());
                    }

                    // --- 关键修改在这里 ---
                    // 我们不再创建和存储临时的 blob URL
                    // 而是直接存储 file 对象
                    const song = {
                        title: title,
                        artist: artist,
                        file: file // <--- 修改点
                    };

                    allPlaylists[currentOpenPlaylist].songs.push(song);
                    appendSongToList(song);
                }

                // 更新歌曲数量
                const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                if (cardToUpdate) {
                    const countElement = cardToUpdate.querySelector('.playlist-count');
                    countElement.textContent = `${allPlaylists[currentOpenPlaylist].songs.length} 首歌曲`;
                }

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

            } catch (error) {
                console.error("导入歌曲失败:", error);
            } finally {
                event.target.value = '';
            }
        });

        // 7. 一个辅助函数，用于将歌曲对象添加到 HTML 列表中
        function appendSongToList(song) {
            const li = document.createElement('li');
            li.className = 'song-item';
            const songId = song.file ? `${song.file.name}-${song.file.lastModified}` : song.url;
            li.dataset.songId = songId;
            li.innerHTML = `
        <input type="checkbox" class="song-checkbox">
        <div class="song-info">
            <div class="song-title">${song.title || '未知歌曲'}</div>
            <div class="song-artist">${song.artist || '未知艺术家'}</div>
        </div>
        <button class="play-button">
            <svg viewBox="0 0 100 100">
                <circle cx="50" cy="50" r="48" stroke="#ccc" stroke-width="4" fill="none"/>
                <polygon points="35,25 75,50 35,75" fill="#555"/>
            </svg>
        </button>
    `;
            songList.appendChild(li);

            const playButton = li.querySelector('.play-button');

            if (song.file) {
                // --- 关键修复：将事件处理函数标记为 async ---
                playButton.addEventListener('click', async (e) => {
                    e.stopPropagation();

                    try {
                        // --- 关键修复：在点击时，主动从数据库加载数据 ---
                        const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                        if (!allPlaylistsData || !allPlaylistsData.value) {
                            throw new Error("无法加载播放列表数据。");
                        }
                        const allPlaylists = allPlaylistsData.value;

                        // 现在可以安全地获取歌曲列表和索引了
                        const currentPlaylistSongs = allPlaylists[currentOpenPlaylist].songs;
                        const songIndex = currentPlaylistSongs.findIndex(s =>
                            s.file && s.file.name === song.file.name && s.file.lastModified === song.file.lastModified
                        );

                        if (songIndex > -1) {
                            startPlayback(currentPlaylistSongs, songIndex);
                        } else {
                            throw new Error("在播放列表中找不到当前歌曲。");
                        }

                    } catch (error) {
                        console.error("播放时出错:", error);
                        alert("播放歌曲时出错，请查看控制台。");
                    }
                });
            } else {
                playButton.disabled = true;
                playButton.style.opacity = 0.3;
                playButton.style.cursor = 'not-allowed';
            }
        }
        // === 新增：上传封面和批量删除的事件逻辑 ===

        // --- 上传封面逻辑 ---
        uploadCoverBtn.addEventListener('click', () => {
            if (isDeleteMode) {
                // 如果在删除模式下，这个按钮会变成“删除所选”
                handleBatchDelete();
            } else {
                // 正常模式下，触发文件选择
                coverUploadInput.click();
            }
        });

        // === 替换为最终修复版：能够处理旧数据并成功保存封面 ===
        coverUploadInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file || !currentOpenPlaylist) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const newCoverUrl = e.target.result;
                try {
                    const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                    // 确保我们有一个对象可以操作，即使数据库是空的
                    let allPlaylists = (allPlaylistsData && allPlaylistsData.value) ? allPlaylistsData.value : {};

                    // --- 关键修复在这里 ---
                    // 检查当前歌单是否存在，或者是否为旧格式（即一个数组而不是对象）
                    if (!allPlaylists[currentOpenPlaylist] || Array.isArray(allPlaylists[currentOpenPlaylist])) {
                        // 如果是旧格式，我们在这里把它“升级”为新格式
                        console.log(`正在升级旧格式歌单: "${currentOpenPlaylist}"`);
                        const oldSongs = Array.isArray(allPlaylists[currentOpenPlaylist]) ? allPlaylists[currentOpenPlaylist] : [];
                        allPlaylists[currentOpenPlaylist] = { songs: oldSongs, coverUrl: null };
                    }

                    // 现在可以安全地更新封面URL了
                    allPlaylists[currentOpenPlaylist].coverUrl = newCoverUrl;
                    await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                    // 实时更新主界面的封面
                    const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                    if (cardToUpdate) {
                        const coverDiv = cardToUpdate.querySelector('.playlist-cover');
                        coverDiv.style.backgroundImage = `url(${newCoverUrl})`;
                    }
                    alert('封面已更新！');

                } catch (error) {
                    console.error('更新封面失败:', error);
                    alert('更新封面失败，请查看控制台获取详情。');
                }
            };
            reader.readAsDataURL(file);
            event.target.value = '';
        });

        // --- 批量删除逻辑 ---
        multiSelectBtn.addEventListener('click', () => {
            isDeleteMode = !isDeleteMode; // 切换删除模式状态

            if (isDeleteMode) {
                songList.classList.add('delete-mode');
                multiSelectBtn.textContent = '取消';
                uploadCoverBtn.textContent = '删除所选';
                uploadCoverBtn.classList.add('delete'); // 添加红色样式
            } else {
                songList.classList.remove('delete-mode');
                multiSelectBtn.textContent = '批';
                uploadCoverBtn.textContent = '封';
                uploadCoverBtn.classList.remove('delete'); // 移除红色样式
                // 退出模式时，取消所有勾选
                songList.querySelectorAll('.song-checkbox').forEach(cb => cb.checked = false);
            }
        });
        // === 替换为最终修复版：兼容新旧数据格式的删除逻辑 ===
        async function handleBatchDelete() {
            const selectedCheckboxes = songList.querySelectorAll('.song-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一首歌曲。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 首歌曲吗？`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const li = cb.closest('.song-item');
                idsToDelete.add(li.dataset.songId);
            });

            try {
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                if (!allPlaylistsData || !allPlaylistsData.value || !allPlaylistsData.value[currentOpenPlaylist]) {
                    alert('无法加载歌单数据，删除失败！');
                    return;
                }
                let allPlaylists = allPlaylistsData.value;
                if (!Array.isArray(allPlaylists[currentOpenPlaylist].songs)) {
                    alert('歌单数据格式不正确，无法删除歌曲！');
                    return;
                }

                // --- 关键修复在这里 ---
                // 在过滤时，对新旧两种数据分别生成ID进行匹配
                const originalSongs = allPlaylists[currentOpenPlaylist].songs;
                allPlaylists[currentOpenPlaylist].songs = originalSongs.filter(song => {
                    let songId;
                    if (song.file) {
                        // 如果是新数据，用文件名和修改日期生成ID
                        songId = `${song.file.name}-${song.file.lastModified}`;
                    } else if (song.url) {
                        // 如果是旧数据，用它自己的URL作为ID
                        songId = song.url;
                    } else {
                        // 如果是无效数据，默认不删除（保留）
                        return true;
                    }
                    // 如果生成的ID在我们待删除的集合中，则这首歌被过滤掉（不返回）
                    return !idsToDelete.has(songId);
                });

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                // 刷新UI
                await openPlaylistDetailView(currentOpenPlaylist);
                multiSelectBtn.click();
                const cardToUpdate = playlistGrid.querySelector(`.playlist-card[data-playlist-name="${currentOpenPlaylist}"]`);
                if (cardToUpdate) {
                    const countElement = cardToUpdate.querySelector('.playlist-count');
                    countElement.textContent = `${allPlaylists[currentOpenPlaylist].songs.length} 首歌曲`;
                }

            } catch (error) {
                console.error('删除歌曲失败:', error);
            }
        }

        // === 新增：灵动岛和播放控制的全部函数 ===
        /**
         * 更新灵动岛折叠状态下的歌曲标题。
         * 如果标题长度超过其容器宽度，则激活滚动动画。
         * @param {string} title - 要显示的歌曲标题。
         */
        function updateScrollingTitle(title) {
            const titleElement = document.getElementById('collapsed-song-title');
            // 获取父级元素，也就是我们的“窗口”
            const windowElement = titleElement.parentElement;

            // 1. 重置状态：移除可能存在的滚动类，以防上一首歌正在滚动
            titleElement.classList.remove('scrolling');

            // 2. 用新标题更新文本内容
            titleElement.textContent = "正在播放：" + title;

            // 3. 检查文本是否溢出（即文本的实际宽度 > 其容器的可见宽度）
            // 我们使用一个短暂的延时，以确保浏览器有时间在检查前完成新文本的渲染和尺寸计算
            setTimeout(() => {
                // scrollWidth 是元素内容的总宽度，clientWidth 是元素的可见宽度
                const isOverflowing = titleElement.scrollWidth > windowElement.clientWidth;

                if (isOverflowing) {
                    // 如果确实溢出了，就添加 'scrolling' 类来启动动画
                    titleElement.classList.add('scrolling');
                }
            }, 100); // 100毫秒的延迟足够了
        }
        // 统一的播放入口函数
        // --- 替换旧的 startPlayback 函数 ---
        async function startPlayback(playlist, index) {
            if (!playlist || index < 0 || index >= playlist.length) return;

            playbackState.playlist = playlist;
            playbackState.currentIndex = index;
            playbackState.currentSong = playlist[index];

            // ... 更新灵动岛UI的代码 ...
            islandSongTitle.textContent = playbackState.currentSong.title;
            islandSongArtist.textContent = playbackState.currentSong.artist;
            updateScrollingTitle(playbackState.currentSong.title);

            const songObjectUrl = URL.createObjectURL(playbackState.currentSong.file);
            audioPlayer.src = songObjectUrl;
            audioPlayer.play().catch(error => console.error("播放失败:", error));

            // 核心修改：当处于“一起听”模式时，调用新的函数来显示并保存“正在播放”提示
            if (sharedListeningState.active && sharedListeningState.contact) {
                const message = `正在播放: ${playbackState.currentSong.title} - ${playbackState.currentSong.artist}`;
                await showSystemNotification(message, sharedListeningState.contact.id);
            }
        }

        // --- 灵动岛 UI 控制 ---
        function showDynamicIsland() {
            dynamicIsland.classList.add('active');
            playbackState.isPlaying = true;
            islandPlayPauseBtn.classList.remove('play');
            islandPlayPauseBtn.classList.add('pause');
        }

        function hideDynamicIsland() {
            dynamicIsland.classList.remove('active', 'expanded');
            playbackState.isPlaying = false;
            islandPlayPauseBtn.classList.remove('pause');
            islandPlayPauseBtn.classList.add('play');
        }

        function formatTime(seconds) {
            const min = Math.floor(seconds / 60);
            const sec = Math.floor(seconds % 60).toString().padStart(2, '0');
            return `${min}:${sec}`;
        }

        // --- 事件监听 ---

        // *** 在这里新增下面的代码 ***

        // === 新增：点击世界书列表项以进行编辑 ===
        worldbookListContainer.addEventListener('click', async (event) => {
            // 如果当前是删除模式，或者点击的是复选框，则不执行编辑操作
            if (isWorldbookDeleteMode || event.target.type === 'checkbox') {
                return;
            }

            const bookItem = event.target.closest('.contact-item');
            if (bookItem) {
                const bookId = parseInt(bookItem.dataset.bookId, 10);
                openWorldbookModal(bookId); // 调用弹窗函数，并传入书籍ID
            }
        });

        // *** 新增代码结束 ***

        // 监听音频播放器事件来控制灵动岛
        audioPlayer.addEventListener('play', showDynamicIsland);
        audioPlayer.addEventListener('pause', hideDynamicIsland);
        // 这是修改后的新代码
        audioPlayer.addEventListener('ended', () => {
            // 歌曲播放结束后，将播放时间重置为0
            audioPlayer.currentTime = 0;
            // 立即重新开始播放当前歌曲，实现单曲循环
            audioPlayer.play();
        });

        audioPlayer.addEventListener('timeupdate', () => {
            const { currentTime, duration } = audioPlayer;
            if (isNaN(duration)) return;

            // 更新进度条
            const progressPercent = (currentTime / duration) * 100;
            progressBarFill.style.width = `${progressPercent}%`;

            // 更新时间显示
            progressCurrentTime.textContent = formatTime(currentTime);
            progressRemainingTime.textContent = `-${formatTime(duration - currentTime)}`;
        });

        audioPlayer.addEventListener('ended', () => {
            islandNextBtn.click(); // 自动播放下一首
        });

        // 灵动岛自身的点击事件
        // === 用下面这个修复后的版本，替换掉您现有的代码 ===

        // 灵动岛自身的点击事件
        // === 最终修复版：灵动岛点击事件 (解决头像消失和歌名不滚动问题) ===

        // === 这是修正了滚动逻辑的最终版本 ===
        dynamicIsland.addEventListener('click', (e) => {
            // 如果点击的是功能按钮，则不触发展开/收起
            if (e.target.closest('.control-button')
                || e.target.closest('.island-action-button')
                || e.target.closest('.shared-avatars')) {
                return;
            }

            const isCurrentlyExpanded = dynamicIsland.classList.contains('expanded');

            // 切换展开/收起状态
            dynamicIsland.classList.toggle('expanded');

            // 根据切换后的状态来执行操作
            if (isCurrentlyExpanded) {
                // 如果是从“展开”变为“收起”
                // 关键修复：在UI切换动画开始后，再检查滚动。
                // 200毫秒的延迟足以让容器尺寸计算正确，且比总动画时间短。
                setTimeout(() => {
                    if (playbackState.currentSong) {
                        updateScrollingTitle(playbackState.currentSong.title);
                    }
                }, 200);

            } else {
                // 如果是从“收起”变为“展开”
                updateSharedListeningUI();
            }
        });
        // 灵动岛内部控制按钮的点击事件
        islandPlayPauseBtn.addEventListener('click', () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
            } else {
                audioPlayer.pause();
            }
        });

        // === “下一首”按钮的最终版 (与上一回答中的代码一致) ===
        islandNextBtn.addEventListener('click', async () => {
            let nextIndex = playbackState.currentIndex + 1;
            if (nextIndex >= playbackState.playlist.length) {
                nextIndex = 0;
            }
            await startPlayback(playbackState.playlist, nextIndex);

            // 如果在"一起听"，则在后台通知AI
            if (sharedListeningState.active && sharedListeningState.contact) {
                const song = playbackState.playlist[nextIndex];

                // 通知AI歌曲已切换
                await callAI(`我刚刚把歌曲切换到了《${song.title}》 - ${song.artist}，请根据聊天记录和歌曲本身做出回应`, sharedListeningState.contact);
            }
        });

        islandPrevBtn.addEventListener('click', async () => {
            let songChanged = false;
            let targetIndex;

            if (audioPlayer.currentTime > 3) {
                targetIndex = playbackState.currentIndex;
                audioPlayer.currentTime = 0;
            } else {
                targetIndex = playbackState.currentIndex - 1;
                if (targetIndex < 0) {
                    targetIndex = playbackState.playlist.length - 1;
                }
                await startPlayback(playbackState.playlist, targetIndex);
                songChanged = true;
            }

            if (songChanged && sharedListeningState.active && sharedListeningState.contact) {
                const song = playbackState.playlist[targetIndex];

                // 通知AI歌曲已切换
                await callAI(`我刚刚把歌曲切换到了《${song.title}》 - ${song.artist}，请根据聊天记录和歌曲本身做出回应`, sharedListeningState.contact);

            }
        });
        // === 新增：处理联系人弹出层的所有逻辑 ===

        // --- 功能 A: 打开和关闭弹出层 ---
        function openModal() {
            addContactModal.style.display = 'flex';
            // 使用一个短暂的延时来确保CSS动画能够触发
            setTimeout(() => {
                addContactModal.style.opacity = '1';
                addContactModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeModal() {
            addContactModal.style.opacity = '0';
            addContactModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            // 等待动画结束后再隐藏元素
            setTimeout(() => {
                addContactModal.style.display = 'none';
                // 重置表单内容
                // 清空输入框和文本域
                aiNameInput.value = '';
                aiPersonaInput.value = '';
                userNameInput.value = '';
                userPersonaInput.value = '';
                aiAvatarPreview.src = 'https://placehold.co/100x100/EFEFEF/AAAAAA?text=AI';
                userAvatarPreview.src = 'https://placehold.co/100x100/EFEFEF/AAAAAA?text=User';
                // 重置上下文记忆
                contextMemoryInput.value = '10';

                // 恢复切换开关和表单的默认显示状态
                roleSwitchCheckbox.checked = false;
                aiForm.classList.add('active');
                userForm.classList.remove('active');
                switchLabels[0].classList.add('active');
                switchLabels[1].classList.remove('active');
                // --- 重置代码结束 ---
            }, 300);// 300ms 对应CSS中的动画时长
        }
        /**
        /**
                 * 功能：根据传入的布尔值，切换全屏模式
                 * @param {boolean} isEnabled - true为启用全屏, false为手机模式
                 */
        function applyFullscreenMode(isEnabled) {
            if (isEnabled) {
                bodyElement.classList.add('fullscreen-mode');
            } else {
                bodyElement.classList.remove('fullscreen-mode');
            }
        }
        fullscreenToggle.addEventListener('change', async () => {
            const isEnabled = fullscreenToggle.checked;
            applyFullscreenMode(isEnabled);
            // 使用新的键名保存状态
            await dbHelper.saveData('settingsStore', 'isFullscreenEnabled', isEnabled);
        });
        modalCloseBtn.addEventListener('click', closeModal);
        addContactModal.addEventListener('click', (event) => {
            // 如果点击的是遮罩背景本身，而不是对话框内容，则关闭
            if (event.target === addContactModal) {
                closeModal();
            }
        });


        // --- 功能 B: 处理AI/用户表单切换 ---
        roleSwitchCheckbox.addEventListener('change', () => {
            const isUser = roleSwitchCheckbox.checked;
            aiForm.classList.toggle('active', !isUser);
            userForm.classList.toggle('active', isUser);
            switchLabels[0].classList.toggle('active', !isUser);
            switchLabels[1].classList.toggle('active', isUser);
        });

        // --- 功能 C: 处理头像上传和预览 ---
        function handleAvatarUpload(inputElement, previewElement) {
            const file = inputElement.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewElement.src = e.target.result; // e.target.result 包含图片的Base64编码
                };
                reader.readAsDataURL(file);
            }
        }
        aiAvatarInput.addEventListener('change', () => handleAvatarUpload(aiAvatarInput, aiAvatarPreview));
        userAvatarInput.addEventListener('change', () => handleAvatarUpload(userAvatarInput, userAvatarPreview));


        // --- 功能 D: 保存联系人到数据库并更新UI ---
        saveContactBtn.addEventListener('click', async () => {
            // 1. 数据校验
            if (!aiNameInput.value.trim() || !userNameInput.value.trim()) {
                alert('AI角色名和你的名字不能为空！');
                return;
            }

            // 2. 收集所有数据
            const newContact = {
                id: Date.now(), // 使用时间戳作为唯一ID
                ai: {
                    name: aiNameInput.value.trim(),
                    persona: aiPersonaInput.value.trim(),
                    avatar: aiAvatarPreview.src // 直接保存Base64编码的图片
                },
                user: {
                    name: userNameInput.value.trim(),
                    persona: userPersonaInput.value.trim(),
                    avatar: userAvatarPreview.src
                },
                contextMemory: parseInt(contextMemoryInput.value, 10) || 10,
                lastMessage: "点击和我聊天吧！" // 默认的最后一条消息
            };

            // 3. 保存到数据库
            try {
                const existingData = await dbHelper.loadData('messageContacts', 'allContacts');
                let contacts = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];
                contacts.push(newContact);
                await dbHelper.saveData('messageContacts', 'allContacts', contacts);

                // 4. 更新UI
                appendContactToList(newContact);

                // 5. 关闭并重置弹出层
                closeModal();

            } catch (error) {
                console.error("保存联系人失败:", error);
                alert("保存失败，请查看控制台日志。");
            }
        });


        // --- 功能 E: 将单个联系人数据显示在列表中 ---
        // --- 功能 E: 将单个联系人数据显示在列表中 (已更新，带复选框) ---
        function appendContactToList(contact) {
            const li = document.createElement('li');
            li.className = 'contact-item';
            li.dataset.contactId = contact.id; // 为以后可能用到的功能（如删除）做准备

            // --- 关键修改：在最前面加入了 input 复选框 ---
            li.innerHTML = `
        <input type="checkbox" class="contact-checkbox">
        <img src="${contact.ai.avatar}" alt="avatar" class="contact-avatar">
        <div class="contact-info">
            <div class="contact-name">${contact.ai.name}</div>
            <div class="contact-last-message">${contact.lastMessage}</div>
        </div>
    `;
            contactList.appendChild(li);
        }


        // --- 功能 F: 从数据库加载所有联系人 ---
        async function loadContacts() {
            const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
            if (contactsData && Array.isArray(contactsData.value)) {
                contactList.innerHTML = ''; // 清空现有列表
                contactsData.value.forEach(contact => {
                    appendContactToList(contact);
                });
            }
        }
        // === 新增：消息列表多选删除的全部逻辑 ===

        let isMessagesDeleteMode = false; // 用于跟踪是否处于删除模式

        // “多选删除”按钮的点击事件
        messagesMultiselectBtn.addEventListener('click', () => {
            isMessagesDeleteMode = !isMessagesDeleteMode; // 切换模式状态

            contactList.classList.toggle('delete-mode', isMessagesDeleteMode);

            if (isMessagesDeleteMode) {
                // 进入删除模式
                messagesMultiselectBtn.textContent = '取消';
                messagesAddBtn.textContent = '删除所选';
                messagesAddBtn.classList.add('delete'); // 添加红色样式
            } else {
                // 退出删除模式
                messagesMultiselectBtn.textContent = '多选';
                messagesAddBtn.textContent = '添加';
                messagesAddBtn.classList.remove('delete');
                // 确保退出时所有复选框都恢复未选中状态
                contactList.querySelectorAll('.contact-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // 修改“添加”按钮的点击事件，使其在删除模式下有不同行为
        messagesAddBtn.addEventListener('click', () => {
            if (isMessagesDeleteMode) {
                handleBatchDeleteContacts(); // 如果在删除模式，就执行删除
            } else {
                openModal(); // 否则，打开添加联系人对话框
            }
        });

        // 真正执行删除操作的函数
        async function handleBatchDeleteContacts() {
            const selectedCheckboxes = contactList.querySelectorAll('.contact-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的对话。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个对话吗？`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                // 从复选框向上找到父级 li 元素，并获取其 ID
                const contactId = cb.closest('.contact-item').dataset.contactId;
                idsToDelete.add(parseInt(contactId, 10)); // 将ID转为数字存入集合
            });

            try {
                const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                if (!contactsData || !Array.isArray(contactsData.value)) {
                    alert('无法加载联系人数据，删除失败！');
                    return;
                }
                let currentContacts = contactsData.value;

                // 过滤掉需要删除的联系人
                const updatedContacts = currentContacts.filter(contact => !idsToDelete.has(contact.id));

                // 将更新后的联系人列表存回数据库
                await dbHelper.saveData('messageContacts', 'allContacts', updatedContacts);

                // 重新加载列表以刷新UI
                await loadContacts();

                // 操作完成后，主动退出删除模式
                messagesMultiselectBtn.click();

            } catch (error) {
                console.error("删除联系人失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }

        // === 新增：聊天界面的所有交互逻辑 ===

        let currentOpenContact = null; // 用于存储当前打开的联系人对象
        let displayedMessageCount = 0; // 添加一个全局变量来跟踪加载更多消息的按钮状态

        // === AI功能新增：System Prompt 定义 ===
        const systemPrompt = `
### 核心身份
你是一个专业的AI角色扮演引擎。你的首要任务是完全沉浸在指定的角色中进行对话，并严格、精确地遵循下方的所有格式化指令。

---

###【【▼▼▼ 角色与世界观背景 (BACKGROUND) - 核心修复 ▼▼▼】】】
{time_info}
**你的角色设定:**
{ai_persona}

**用户的角色设定:**
{user_persona}

**当前对话相关的世界观、背景、知识库:**
{world_book_content}
---

###【【【绝对指令 (ABSOLUTE DIRECTIVES)】】】
这是最高优先级的规则，绝不允许违反。

1.  **禁止泄露上下文格式**: 你的历史记录中会看到 "[角色: ...]" 或 "[用户: ...]" 的前缀，这些仅供你理解上下文。你的回复【【永远、绝对、在任何情况下】】都不准包含 "[角色: ...]" 或 "[用户: ...]" 这种格式。直接输出内容即可。
2.  **所有文本必须包裹**: 你的任何一句对话，无论长短，哪怕只有一个字，都【【必须】】被 [MESSAGE_START]和[MESSAGE_END] 包裹。没有例外。
3.  **精确使用标签**: 所有特殊技能的标签，例如 [MESSAGE_START] 和 [MESSAGE_END]，必须拼写完全正确，不能简写为 [END] 或其他任何形式。

---

### 特殊技能 (SKILLS)
你必须根据情境，在回复中运用以下技能。

**1. 普通消息:**
   - **用途**: 用于输出角色的每一句对话。
   - **格式**: [MESSAGE_START]你的对话内容[MESSAGE_END]
   - **规则**: 这是最基础的技能，所有对话文本都必须使用。

**2. 转账:**
   - **用途**: 当你扮演的角色决定给用户转账时使用。
   - **格式**: [TRANSFER_START]转账备注-金额[TRANSFER_END]

**3. 理解表情包:**
   - **用途**: 当你看到用户输入格式为 [EMOJI_START]备注[EMOJI_END] 时，这代表用户发送了一个主题为“备注”的表情包。
   - **规则**: 你【【不准】】在回复中提及 [EMOJI_START] 这个标签或“表情包”这个词。你需要像真正看到图片一样，根据“备注”的内容（如：'dog', 'calm', 'cry'）自然地对这个表情包的情感或内容做出回应。

**4. 回应听歌邀请:**
   - **用途**: 当你看到用户输入格式为 [MUSIC_SHARE]... 时，代表用户邀请你一起听歌。
   - **规则**: 如果你扮演的角色决定接受邀请，你的回复中【【必须】】在相应的对话之后，另起一行加入 [ACCEPT_INVITE] 标签。如果拒绝，则正常回复即可。

**5. 发送表情包 (Send Sticker):**
   - **用途**: 当你扮演的角色想要发送一个表情包来表达情感时使用。
   - **格式**: [STICKER_START]表情包的准确文字描述[STICKER_END]
   - **规则**: 你【【必须】】从下面的可用列表中选择一个，并使用一模一样的文字描述。不准自己编撰描述。
   - **你当前可用的表情包如下**:
  - 可爱动漫小狗趴在手机旁边等消息
  - 求求了
  - 喝AD钙
  - 无语
  - 摸摸小猫头
  - 你脑子进水了
  - 汗流浃背
  - 小猫wink
  - emo了
  - 太美味了
  - 已老实
  - 过去软弱的我已经死了！现在是更软弱的我
  - 哦？是吗？
  - 这张卡你拿着，密码是0，余额也是
  - 强忍泪水
  - 想不想我
  - 你是个二百五！
  - 有一点骚
  - 能好好爱我吗，emo了。
  - 你单身！！
  - 恶心
  - 无语了家人们
  - 哥帅不帅?
  - 好困呀
---

### 回复生成流程
1.  分析用户的最新消息和历史对话。
2.  根据你的角色设定，构思出回应。
3.  检查你的回应，确保它严格遵守了【绝对指令】和【特殊技能】中的所有格式要求。
4.  最终输出格式化之后的内容。

---

### 示例 (EXAMPLES)

**示例1 (单条消息):**
[MESSAGE_START]我收到你的消息了，知道了。[MESSAGE_END]

**示例2 (混合消息):**
[MESSAGE_START]好呀，那我们去买点好吃的吧！[MESSAGE_END]
[TRANSFER_START]买零食的钱-80[TRANSFER_END]
[MESSAGE_START]这些应该够了！[MESSAGE_END]

**示例3 (接受听歌邀请):**
[MESSAGE_START]哦？周杰伦的歌，那必须听听！[MESSAGE_END]
[ACCEPT_INVITE]

**示例4 (回应表情包):**
(当收到的用户输入是 [EMOJI_START]cry[EMOJI_END])
[MESSAGE_START]怎么了？别哭呀，有什么事和我说说。[MESSAGE_END]

**示例5 (发送表情包):**
[MESSAGE_START]我等到花儿都谢了...[MESSAGE_END]
[STICKER_START]可爱动漫小狗趴在手机旁边等消息[STICKER_END]

---
### 最终审查与检查
你的最终输出【【绝对、必须、永远】】不能包含以下任何文本：
- [角色:
- [用户:
- ]
- 角色:
- 用户:

`;


        // === AI功能新增：消息格式化函数 ===

        function formatMessageForAI(message, contact) {
            if (!contact) return "";

            const role = message.sender === 'user' ? '用户' : '角色';
            const name = message.sender === 'user' ? contact.user.name : contact.ai.name;

            return `[${role}: ${name}]\n${message.text}`;
        }

        // === AI功能新增：调用AI的核心函数 ===

        /**
         * 解释：
         * 这是与AI交互的核心。它是一个异步函数（async），因为网络请求需要时间。
         * @param {string} triggerMessage - 触发本次AI调用的特定消息或指令。
         */
        //

        // === callAI 函数的最终修复版 (V7)，修复了 "settings is not defined" 的拼写错误 ===
        async function callAI(triggerMessage, contact) {
            if (isAiReplying) return;
            isAiReplying = true;
            const contactId = contact.id;
            let initialTypingIndicator = null;

            try {
                deleteMessagesBtn.disabled = true;
                if (currentOpenContact && currentOpenContact.id === contactId) {
                    initialTypingIndicator = showTypingIndicator();
                }
                // --- ▼▼▼ 新增的时间感知逻辑 ▼▼▼ ---
                let timeInfo = ""; // 默认时间信息为空字符串
                // 如果当前联系人开启了时间感知
                if (contact.timePerceptionEnabled) {
                    const now = new Date();
                    // 格式化一个对AI友好的、详细的中文时间字符串
                    const formattedDateTime = now.toLocaleString('zh-CN', {
                        year: 'numeric', month: 'long', day: 'numeric',
                        weekday: 'long', hour: '2-digit', minute: '2-digit'
                    });
                    // 准备要注入到 systemPrompt 中的文本
                    timeInfo = `### 现实时间参考\n当前用户的现实时间是：${formattedDateTime}\n---\n\n`;
                }

                let worldBookContent = "无特定世界观设定，请自由发挥。";
                if (contact.linkedWorldBookIds && contact.linkedWorldBookIds.length > 0) {
                    const worldbookData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                    if (worldbookData && Array.isArray(worldbookData.value)) {
                        const linkedBooksContent = worldbookData.value
                            .filter(book => contact.linkedWorldBookIds.includes(book.id))
                            .map(book => book.content)
                            .join('\n\n---\n\n');

                        if (linkedBooksContent) {
                            worldBookContent = linkedBooksContent;
                        }
                    }
                }

                const settingsData = await dbHelper.loadData('settingsStore', 'apiSettings');

                // --- 关键修复：将错误的 "settings.value" 改为 "settingsData.value" ---
                if (!settingsData || !settingsData.value.url || !settingsData.value.key || !settingsData.value.model) {
                    throw new Error("API未完整配置，请在设置中检查。");
                }

                const { url, key, model, temperature } = settingsData.value;
                const finalSystemPrompt = systemPrompt
                    .replace('{time_info}', timeInfo)
                    .replace('{ai_persona}', `姓名: ${contact.ai.name}\n人设: ${contact.ai.persona}`)
                    .replace('{user_persona}', `姓名: ${contact.user.name}\n人设: ${contact.user.persona}`)
                    .replace('{world_book_content}', worldBookContent);

                const history = contact.history || [];

                let contextSize = contact.contextMemory;
                if (typeof contextSize !== 'number' || isNaN(contextSize) || contextSize < 0) {
                    contextSize = 10;
                }
                const recentHistory = contextSize > 0 ? history.slice(-contextSize) : [];

                const messages = [{ role: "system", content: finalSystemPrompt }];

                recentHistory.forEach(msg => {
                    messages.push({
                        role: msg.sender === 'user' ? 'user' : 'assistant',
                        content: formatMessageForAI(msg, contact)
                    });
                });

                // ===================================
                // THIS IS THE NEW, CORRECTED CODE
                // ===================================
                messages.push({ role: "user", content: triggerMessage });


                const response = await fetch(`${url}/v1/chat/completions`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${key}` },
                    body: JSON.stringify({ model, messages, temperature: parseFloat(temperature) || 1.0 })
                });

                if (!response.ok) throw new Error(`API请求失败: ${response.status}`);

                const data = await response.json();
                const aiContent = data.choices[0].message.content;
                const messageBlocks = aiContent.split(/(?=\[(?:MESSAGE_START|TRANSFER_START|STICKER_START)\])/g).filter(block => block.trim());

                const savedMessages = [];
                if (messageBlocks.length > 0) {
                    for (const block of messageBlocks) {
                        const aiMessage = {
                            sender: 'ai',
                            text: block.trim(),
                            timestamp: new Date(),
                            uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9) // 创建唯一ID
                        };
                        await saveMessageToHistory(aiMessage, contactId);
                        savedMessages.push(aiMessage);
                    }
                } else {
                    const rawAiMessage = { sender: 'ai', text: aiContent, timestamp: new Date() };
                    await saveMessageToHistory(rawAiMessage, contactId);
                    savedMessages.push(rawAiMessage);
                }

                updateChatViewWithAIResponse(contactId, savedMessages, initialTypingIndicator);

            } catch (error) {
                console.error("调用AI失败:", error);
                if (initialTypingIndicator) initialTypingIndicator.remove();
                alert(`AI回复失败: ${error.message}`);
            } finally {
                console.log(
                    "%c--- AI 回复结束 ---",
                    "color: green; font-weight: bold;",
                    `内存中的消息数量: ${currentOpenContact.history.length}`,
                    "最后5条消息:", currentOpenContact.history.slice(-5)
                );
                isAiReplying = false;
                deleteMessagesBtn.disabled = false;
            }
        }
        // 你需要实现 saveMessageToHistory 函数，它应该像这样：
        // ===================================
        // 这是新的、简化的 saveMessageToHistory
        // ===================================
        async function saveMessageToHistory(message, contactId) {
            // 确保我们操作的是当前打开的联系人
            if (!currentOpenContact || currentOpenContact.id !== contactId) return;

            // 1. 确保 history 数组存在
            if (!Array.isArray(currentOpenContact.history)) {
                currentOpenContact.history = [];
            }

            // 2. 直接修改内存中的 currentOpenContact 对象
            currentOpenContact.history.push(message);
            currentOpenContact.lastMessage = cleanMessageForPreview(message.text);

            // 3. 调用新的主保存函数来处理数据库同步
            await saveCurrentContactToDatabase();

            // 4. (可选) 实时更新消息列表页的预览
            const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${contactId}"]`);
            if (contactItemInList) {
                contactItemInList.querySelector('.contact-last-message').textContent = currentOpenContact.lastMessage;
            }
        }
        // === AI功能修改：发送消息的总控函数 ===
        // 用这个新版本替换旧的 sendMessage 函数
        async function sendMessage(messageData) {
            if (!currentOpenContact) return;

            let messageObject;

            // 判断传入的是纯文本还是一个带类型的对象
            if (typeof messageData === 'string') {
                if (!messageData.trim()) return; // 如果是空字符串，则不发送
                messageObject = { type: 'text', text: messageData.trim() };
            } else {
                messageObject = messageData;
            }

            // 组合成完整的用户消息，包含发送者、时间戳等信息
            const userMessage = {
                sender: 'user',
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9),
                ...messageObject // 将 type, text, url 等属性合并进来
            };

            // 1. 立即在界面上显示（addMessageToView 稍后会升级）
            addMessageToView(userMessage);

            // 2. 将完整的消息对象存入数据库
            await saveMessageToHistory(userMessage, currentOpenContact.id);

            // 3. 将消息的 .text 属性发送给 AI
            if (messageObject.type !== 'sticker') {
                await callAI(userMessage.text, currentOpenContact);
            }


            // 清空输入框（如果是通过输入框发送的话）
            chatMessageInput.value = '';
        }


        // === AI功能新增：逐条延时显示AI消息的函数 ===

        /**
         * 解释：
         * 这个函数接收一个包含多条消息文本的数组，然后逐条显示它们。
         * 'async' 和 'await' 的使用让我们可以轻松地在循环中实现延时。
         * @param {string[]} messages - AI回复的纯文本消息数组
         */
        //
        // 粘贴这两个全新的函数
        //

        /**
         * 功能1：创建一个包含“正在输入”动画的AI气泡，并返回该气泡元素的引用
         */
        function createTypingBubble() {
            const row = document.createElement('div');
            row.className = 'message-row ai';

            const avatar = document.createElement('img');
            avatar.className = 'chat-avatar';
            avatar.src = currentOpenContact.ai.avatar;
            const avatarSettings = currentOpenContact.avatarSettings || { radius: '50%' };
            avatar.style.borderRadius = avatarSettings.radius;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble ai-bubble';
            bubble.innerHTML = `
        <div class="typing-animation">
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
        </div>
    `;

            row.appendChild(avatar);
            row.appendChild(bubble);
            chatMessagesContainer.appendChild(row);
            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;

            return bubble; // 返回这个新创建的气泡元素，以便后续修改
        }

        /**
         * 功能2（全新版本）：逐条显示AI消息，并实现“先显示动画，再填充文字”的动态效果
         */

        // 这是 displayAiMessagesSequentially 函数的【新版】，能处理预先创建的加载动画
        //
        async function displayAiMessagesSequentially(messages, initialBubble) {
            // 使用 .entries() 来同时获取消息的索引和内容
            for (const [index, text] of messages.entries()) {
                if (!text) continue;

                let currentBubble;

                // 判断使用哪个气泡：
                // 如果是第一条消息 (index === 0)，就使用 callAI 预先创建的那个
                // 如果是后续消息，就新建一个
                if (index === 0) {
                    currentBubble = initialBubble;
                } else {
                    currentBubble = createTypingBubble();
                }

                // 模拟打字延迟
                const typingDelay = Math.min(Math.max(text.length * 500, 400), 8000);
                await new Promise(resolve => setTimeout(resolve, typingDelay));

                // 将动画替换为真实的文字内容
                currentBubble.innerHTML = '';
                currentBubble.textContent = text;

                // 保存到历史记录
                const aiMessage = {
                    sender: 'ai',
                    text: text,
                    timestamp: new Date()
                };
                await saveMessageToHistory(aiMessage);
            }
        }
        // --- 功能 A: 打开聊天界面 (已更新，只加载最新的30条) ---
        async function openChatView(contactId) {
            const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
            if (!contactsData || !Array.isArray(contactsData.value)) {
                console.error("无法加载联系人数据");
                return;
            }
            currentOpenContact = contactsData.value.find(c => c.id === contactId);
            if (!currentOpenContact) {
                console.error(`找不到 ID 为 ${contactId} 的联系人`);
                return;
            }

            applyChatViewSettings(currentOpenContact);
            chatContactName.textContent = currentOpenContact.ai.name;
            chatMessagesContainer.innerHTML = ''; // 清空所有旧消息和按钮

            const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];

            // 如果消息总数超过30条，则动态创建并添加按钮
            if (history.length > 30) {
                const loadMoreBtn = document.createElement('button');
                loadMoreBtn.id = 'load-more-messages-btn';
                loadMoreBtn.className = 'header-text-button';
                loadMoreBtn.textContent = '查看更早的消息';
                loadMoreBtn.style.margin = '15px auto'; // 居中样式

                // 绑定事件监听器
                loadMoreBtn.addEventListener('click', loadMoreMessages);

                // 将按钮添加到消息容器的最前面
                chatMessagesContainer.appendChild(loadMoreBtn);
            }

            const initialMessages = history.slice(-30);
            initialMessages.forEach(message => {
                addMessageToView(message);
            });

            phoneFrame.classList.add('show-chat');
// 滚动到底部（最终修复版，区分加载和交互）
            const scrollToBottomOnLoad = (behavior = 'auto') => { // 默认改为 'auto'
                chatMessagesContainer.scrollTo({
                    top: chatMessagesContainer.scrollHeight,
                    behavior: behavior
                });
            };

            // 1. 初始滚动，强制使用 'auto' 瞬时定位
            setTimeout(() => scrollToBottomOnLoad('auto'), 150);

            // 2. 在所有图片加载完成后，执行一次最终的瞬时定位
            const images = chatMessagesContainer.querySelectorAll('.chat-avatar, .sticker-bubble');
            const promises = [];
            images.forEach(img => {
                if (img.src && !img.complete) {
                    promises.push(img.decode().catch(e => console.error("图片解码失败", e)));
                }
            });

            Promise.all(promises).then(() => {
                console.log("所有图片加载完成，执行最终瞬时滚动。");
                scrollToBottomOnLoad('auto'); // 这里也必须是 'auto'
            });

        // 当所有图片的 promise 都完成后
        Promise.all(promises).then(() => {
            console.log("所有图片加载完成，执行最终滚动。");
            scrollToBottom();
        });
        }

        // 重新修改 loadMoreMessages 函数



        // 替换掉旧的 loadMoreMessages 函数
        async function loadMoreMessages() {
            if (!currentOpenContact) return;

            const loadMoreBtn = document.getElementById('load-more-messages-btn');
            if (!loadMoreBtn) return;

            // 1. 保存当前的滚动高度，以便之后恢复视图
            const oldScrollHeight = chatMessagesContainer.scrollHeight;

            const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];

            // 2. 正确计算需要加载的下一批消息
            const messagesInViewCount = chatMessagesContainer.querySelectorAll('.message-row').length;
            const endIndex = history.length - messagesInViewCount;

            if (endIndex <= 0) {
                loadMoreBtn.remove(); // 没有更多消息了，移除按钮
                return;
            }

            const startIndex = Math.max(0, endIndex - 30); // 一次加载30条
            const messagesToAdd = history.slice(startIndex, endIndex);

            // 3. 将新消息插入到列表顶部（在按钮之后，但在旧消息之前）
            const firstOldMessage = loadMoreBtn.nextSibling;
            messagesToAdd.forEach(message => {
                // 使用一个不会产生副作用（如自动滚动）的辅助函数来创建消息元素
                const messageElement = createMessageElement(message);
                chatMessagesContainer.insertBefore(messageElement, firstOldMessage);
            });

            // 4. 恢复滚动条位置，让用户感觉不到界面跳动
            const newScrollHeight = chatMessagesContainer.scrollHeight;
            chatMessagesContainer.scrollTop += (newScrollHeight - oldScrollHeight);

            // 5. 如果已经加载完所有历史记录，则移除按钮
            if (startIndex === 0) {
                loadMoreBtn.remove();
            }
        }
        // 新增这个辅助函数
        function createMessageElement(message) {
            const settings = currentOpenContact.avatarSettings || { show: true, radius: '50%' };

            const row = document.createElement('div');
            row.className = 'message-row';
            row.dataset.timestamp = message.timestamp.toString();
            row.dataset.uuid = message.uuid;

            const wrapper = document.createElement('div');
            wrapper.className = 'message-content-wrapper';

            const avatar = document.createElement('img');
            avatar.className = 'chat-avatar';
            avatar.style.borderRadius = settings.radius;

            if (message.sender === 'user') {
                wrapper.classList.add('user');
                avatar.src = currentOpenContact.user.avatar;
            } else {
                wrapper.classList.add('ai');
                avatar.src = currentOpenContact.ai.avatar;
            }

            const transferRegex = /\[TRANSFER_START\]([\s\S]*?)-(\d*\.?\d+)\[TRANSFER_END\]/;
            const transferMatch = message.text.match(transferRegex);

            if (transferMatch) {
                const remark = transferMatch[1].trim();
                const amount = parseFloat(transferMatch[2]).toFixed(2);

                const card = document.createElement('div');
                card.style.cssText = "width: 200px; height: 100px; position: relative; background: white; overflow: hidden; border-radius: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
                card.innerHTML = `
            <div style="left: 23px; top: 11px; position: absolute; color: black; font-size: 16px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">转账</div>
            <div style="left: 23px; top: 42px; position: absolute; color: #AFAFAF; font-size: 11px; font-family: sans-serif; font-weight: 400; word-wrap: break-word">${remark}</div>
            <div style="width: 130px; height: 22px; left: 20px; top: 64px; position: absolute; color: black; font-size: 20px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">¥ ${amount}</div>
            <div style="width: 160px; height: 0px; left: 20px; top: 37px; position: absolute; border: 0.5px solid rgba(118, 118, 128, 0.12);"></div>
            <div style="width: 24px; height: 24px; left: 156px; top: 8px; position: absolute;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.295 16.705L12.585 12.415L8.295 8.125C8.1067 7.9367 8.00091 7.6813 8.00091 7.415C8.00091 7.1487 8.1067 6.89331 8.295 6.705C8.48331 6.5167 8.7387 6.41091 9.005 6.41091C9.2713 6.41091 9.5267 6.5167 9.715 6.705L14.715 11.705C14.8087 11.798 14.8831 11.9086 14.9339 12.0304C14.9847 12.1523 15.0108 12.283 15.0108 12.415C15.0108 12.547 14.9847 12.6777 14.9339 12.7996C14.8831 12.9214 14.8087 13.032 14.715 13.125L9.715 18.125C9.62204 18.2187 9.50144 18.2931 9.36958 18.3439C9.23772 18.3947 9.09699 18.4208 8.955 18.4208C8.81301 18.4208 8.67228 18.3947 8.54042 18.3439C8.40856 18.2931 8.28796 18.2187 8.195 18.125C8.0067 17.9367 7.90091 17.6813 7.90091 17.415C7.90091 17.1487 8.0067 16.8933 8.195 16.705L8.295 16.705Z" fill="#363636"/>
                </svg>
            </div>
        `;
                wrapper.appendChild(avatar);
                wrapper.appendChild(card);
            } else {
                const bubble = document.createElement('div');
                bubble.className = 'chat-bubble';
                if (message.sender === 'user') {
                    bubble.classList.add('user-bubble');
                } else {
                    bubble.classList.add('ai-bubble');
                }
                let visibleText = message.text;
                const messageRegex = /\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/;
                const messageMatch = message.text.match(messageRegex);
                if (messageMatch && messageMatch[1]) {
                    visibleText = messageMatch[1].trim();
                }
                bubble.textContent = visibleText;
                wrapper.appendChild(avatar);
                wrapper.appendChild(bubble);
            }

            row.appendChild(wrapper);
            return row;
        }

        // --- 功能 B: 关闭聊天界面 ---
        function closeChatView() {
            phoneFrame.classList.remove('show-chat');
            // 动画结束后清理数据，防止下次打开时闪烁旧内容
            setTimeout(() => {
                currentOpenContact = null;
            }, 350); // 动画时长为350ms
        }

        // --- 功能 C: 绑定事件 ---

        // 使用“事件委托”来处理联系人列表的点击事件。
        // 这样做的好处是，即使是动态添加的联系人，点击事件也同样有效。
        contactList.addEventListener('click', (event) => {
            // 如果当前处于删除模式，并且点击的是复选框，则不进入聊天
            if (contactList.classList.contains('delete-mode') && event.target.classList.contains('contact-checkbox')) {
                return;
            }

            // 查找被点击的、最接近的父级 .contact-item 元素
            const contactItem = event.target.closest('.contact-item');
            if (contactItem) {
                const contactId = parseInt(contactItem.dataset.contactId, 10);
                openChatView(contactId);
            }
        });

        // 为聊天界面的返回按钮绑定点击事件
        chatBackButton.addEventListener('click', closeChatView);

        // (可选) 为发送按钮添加一个简单的打印功能，为后续开发做准备
        // === 更新：“发送”按钮的点击事件 (最终版) ===
        // ===================================
        // THIS IS THE NEW, CORRECTED CODE
        // ===================================
        chatSendButton.addEventListener('click', async () => {
            const messageText = chatMessageInput.value.trim();
            if (!messageText || !currentOpenContact) {
                return;
            }

            // 1. 构造一个完整的消息对象
            const userMessage = {
                sender: 'user',
                text: messageText,
                timestamp: new Date(),
                uuid: Date.now() + '-' + Math.random().toString(36).substr(2, 9)
            };

            // 2. 清空输入框并立即在UI上显示
            chatMessageInput.value = '';
            addMessageToView(userMessage);

            // 3. 调用唯一的、可靠的保存函数来处理数据库
            await saveMessageToHistory(userMessage, currentOpenContact.id);

        });
        // === 监听聊天输入框的回车键事件 ===
        chatMessageInput.addEventListener('keydown', (event) => {
            // 检查按下的键是否是 "Enter"
            if (event.key === 'Enter') {
                // 阻止 "Enter" 键的默认行为（例如换行或提交表单）
                event.preventDefault();

                // 模拟一次点击发送按钮的操作
                chatSendButton.click();
            }
        });
        // === 新增：聊天设置弹出层的全部逻辑 ===

        const defaultBubbleCss = `.user-bubble {
    background-color: #007AFF;
    color: white;
    border-bottom-right-radius: 4px;
    align-self: flex-end;
}
.ai-bubble {
    background-color: #E5E5EA;
    color: black;
    border-bottom-left-radius: 4px;
    align-self: flex-start;
}`;

        // --- 功能 A: 打开和关闭设置弹出层 ---
        // === 更新 openChatSettingsModal (支持世界书多选) ===
        async function openChatSettingsModal() {
            if (!currentOpenContact) return;

            // --- 加载角色信息等 (这部分不变) ---
            aiAvatarPreviewSettings.src = currentOpenContact.ai.avatar;
            aiNameInputSettings.value = currentOpenContact.ai.name;
            aiPersonaInputSettings.value = currentOpenContact.ai.persona;
            userAvatarPreviewSettings.src = currentOpenContact.user.avatar;
            userNameInputSettings.value = currentOpenContact.user.name;
            userPersonaInputSettings.value = currentOpenContact.user.persona;
            contextMemoryInputSettings.value = currentOpenContact.contextMemory || 10;
            bubbleCssInput.value = currentOpenContact.customBubbleCss || defaultBubbleCss;
            const avatarSettings = currentOpenContact.avatarSettings || { show: true, radius: '50%' };
            showAvatarsToggle.checked = avatarSettings.show;
            avatarRadiusInput.value = avatarSettings.radius;

            // --- 核心修改：加载并渲染世界书多选列表 ---
            const container = document.getElementById('worldbook-multiselect-container');
            container.innerHTML = ''; // 清空旧的选项

            try {
                const worldbookData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                const allBooks = (worldbookData && Array.isArray(worldbookData.value)) ? worldbookData.value : [];

                // 获取当前对话已关联的世界书ID数组
                const linkedBookIds = new Set(currentOpenContact.linkedWorldBookIds || []);

                if (allBooks.length > 0) {
                    allBooks.forEach(book => {
                        const item = document.createElement('div');
                        item.className = 'multiselect-item';

                        const isChecked = linkedBookIds.has(book.id); // 判断是否应该被勾选

                        item.innerHTML = `
                    <input type="checkbox" id="book-${book.id}" value="${book.id}" ${isChecked ? 'checked' : ''}>
                    <label for="book-${book.id}">${book.name}</label>
                `;
                        container.appendChild(item);
                    });
                } else {
                    container.innerHTML = '<span style="color: #888; font-size: 13px;">暂无世界书</span>';
                }

            } catch (error) {
                console.error("加载世界书到设置失败:", error);
                container.innerHTML = '<span style="color: red; font-size: 13px;">加载失败</span>';
            }

            // --- 显示弹窗 (这部分不变) ---
            chatSettingsModal.style.display = 'flex';
            setTimeout(() => {
                chatSettingsModal.style.opacity = '1';
                chatSettingsModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeChatSettingsModal() {
            chatSettingsModal.style.opacity = '0';
            chatSettingsModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                chatSettingsModal.style.display = 'none';
            }, 300);
        }

        chatSettingsButton.addEventListener('click', openChatSettingsModal);
        chatSettingsCloseBtn.addEventListener('click', closeChatSettingsModal);

        // --- 功能 B: 绑定设置弹出层内部的各种交互 ---

        // 角色切换
        roleSwitchCheckboxSettings.addEventListener('change', () => {
            const isUser = roleSwitchCheckboxSettings.checked;
            aiFormSettings.classList.toggle('active', !isUser);
            userFormSettings.classList.toggle('active', isUser);
            const settingsSwitchLabels = chatSettingsModal.querySelectorAll('.switch-label');
            settingsSwitchLabels[0].classList.toggle('active', !isUser);
            settingsSwitchLabels[1].classList.toggle('active', isUser);
        });

        // 头像上传
        aiAvatarInputSettings.addEventListener('change', () => handleAvatarUpload(aiAvatarInputSettings, aiAvatarPreviewSettings));
        userAvatarInputSettings.addEventListener('change', () => handleAvatarUpload(userAvatarInputSettings, userAvatarPreviewSettings));

        // 恢复默认气泡样式
        restoreBubbleCssBtn.addEventListener('click', () => {
            bubbleCssInput.value = defaultBubbleCss;
        });

        // 聊天背景
        uploadChatBgBtn.addEventListener('click', () => chatBgUploadInput.click());
        chatBgUploadInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    // 这是一个临时预览，保存时才会真正生效
                    chatScreen.style.backgroundImage = `url(${e.target.result})`;
                };
                reader.readAsDataURL(file);
            }
        });
        resetChatBgBtn.addEventListener('click', () => {
            chatScreen.style.backgroundImage = 'none';
            chatScreen.style.backgroundColor = '#f0f2f5';
        });

        // === 修正版：清空聊天记录功能 (增加数据库操作) ===
        clearHistoryBtn.addEventListener('click', async () => {
            if (!currentOpenContact) return;

            if (confirm('警告：此操作将永久删除此对话的所有聊天记录，且无法恢复。确定要继续吗？')) {
                try {
                    // 1. **从数据库加载最新的完整联系人列表**
                    const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                    let allContacts = allContactsData.value || [];
                    const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                    if (contactIndex > -1) {
                        // 2. **清空该联系人的历史记录，并更新最后一条消息**
                        allContacts[contactIndex].history = [];
                        allContacts[contactIndex].lastMessage = "聊天记录已清空";

                        // 3. **将修改后的完整联系人列表，存回数据库**
                        await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

                        // 4. **更新当前内存中的数据和UI**
                        currentOpenContact.history = [];
                        currentOpenContact.lastMessage = "聊天记录已清空";
                        chatMessagesContainer.innerHTML = ''; // 清空聊天界面

                        // 5. 更新消息列表页的预览
                        const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
                        if (contactItemInList) {
                            contactItemInList.querySelector('.contact-last-message').textContent = "聊天记录已清空";
                        }

                        alert('聊天记录已成功清除！');
                    } else {
                        throw new Error("在数据库中找不到当前联系人。");
                    }
                } catch (error) {
                    console.error("清除聊天记录失败:", error);
                    alert(`操作失败: ${error.message}`);
                }
            }
        });


        // 找到你已有的 saveChatSettingsBtn 事件监听器，并用下面的代码替换其内部逻辑：

        saveChatSettingsBtn.addEventListener('click', async () => {
            if (!currentOpenContact) return;

            try {
                // --- 修复开始 ---

                // 步骤 1: 从数据库加载完整的联系人数组。
                const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                let allContacts = (allContactsData && Array.isArray(allContactsData.value)) ? allContactsData.value : [];

                // 步骤 2: 在该数组中找到我们需要更新的那个联系人。
                const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                if (contactIndex > -1) {
                    // 步骤 3: 将设置弹窗中的所有新信息应用到那个联系人对象上。

                    // 更新 AI/用户信息
                    allContacts[contactIndex].ai.name = aiNameInputSettings.value.trim();
                    allContacts[contactIndex].ai.persona = aiPersonaInputSettings.value.trim();
                    allContacts[contactIndex].ai.avatar = aiAvatarPreviewSettings.src;
                    allContacts[contactIndex].user.name = userNameInputSettings.value.trim();
                    allContacts[contactIndex].user.persona = userPersonaInputSettings.value.trim();
                    allContacts[contactIndex].user.avatar = userAvatarPreviewSettings.src;
                    allContacts[contactIndex].contextMemory = parseInt(contextMemoryInputSettings.value, 10);

                    // 更新个性化设置
                    allContacts[contactIndex].customBubbleCss = bubbleCssInput.value;
                    allContacts[contactIndex].avatarSettings = {
                        show: showAvatarsToggle.checked,
                        radius: avatarRadiusInput.value.trim() || '50%'
                    };
                    const bgImage = chatScreen.style.backgroundImage;
                    allContacts[contactIndex].chatBackground = bgImage.includes('url') ? bgImage : null;



                    // 收集所有被勾选的世界书ID
                    const selectedWorldBookIds = [];
                    const checkedBooks = document.querySelectorAll('#worldbook-multiselect-container input:checked');
                    checkedBooks.forEach(checkbox => {
                        selectedWorldBookIds.push(parseInt(checkbox.value, 10));
                    });

                    // 将收集到的ID数组存入联系人对象
                    allContacts[contactIndex].linkedWorldBookIds = selectedWorldBookIds;



                    // 同时，也要更新内存中的 'currentOpenContact' 变量，这样UI可以立即正确刷新
                    currentOpenContact = allContacts[contactIndex];
                } else {
                    // 如果因为某些原因找不到联系人，就停止并报错。
                    throw new Error("在数据库中找不到要保存的联系人。");
                }

                // 步骤 4: 将整个修改后的 'allContacts' 数组完整地保存回数据库。
                await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

                // --- 修复结束 ---


                // 现在，你其余的UI更新代码可以照常运行。
                // 它们会使用刚刚被更新过的 'currentOpenContact' 对象。
                applyChatViewSettings(currentOpenContact);
                chatContactName.textContent = currentOpenContact.ai.name;

                // 更新主消息列表中的名称和头像
                const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
                if (contactItemInList) {
                    contactItemInList.querySelector('.contact-name').textContent = currentOpenContact.ai.name;
                    contactItemInList.querySelector('.contact-avatar').src = currentOpenContact.ai.avatar;
                }

                closeChatSettingsModal();
                alert('设置已成功保存！');

            } catch (error) {
                console.error("保存聊天设置失败:", error);
                alert(`保存失败: ${error.message}`);
            }
        });
        // --- 功能 D: 应用所有聊天视图的个性化设置 (已更新) ---
        function applyChatViewSettings(contact) {
            // 应用气泡样式
            customBubbleStyles.innerHTML = contact.customBubbleCss || defaultBubbleCss;

            // 应用聊天背景
            if (contact.chatBackground) {
                chatScreen.style.backgroundImage = contact.chatBackground;
            } else {
                chatScreen.style.backgroundImage = 'none';
                chatScreen.style.backgroundColor = '#f0f2f5';
            }

            // 应用头像显示设置
            const avatarSettings = contact.avatarSettings || { show: true, radius: '50%' };
            chatMessagesContainer.classList.toggle('hide-avatars', !avatarSettings.show);

            // --- 新增的关键修复 ---
            // 实时更新当前屏幕上所有头像的圆角
            const allAvatars = document.querySelectorAll('#chat-messages-container .chat-avatar');
            allAvatars.forEach(avatar => {
                avatar.style.borderRadius = avatarSettings.radius;
            });
        }
        /**
         * 新增：净化消息文本，用于在联系人列表生成预览
         * @param {string} text - 原始消息文本
         * @returns {string} - 清理掉特殊标签后的预览文本
         */
        function cleanMessageForPreview(text) {
            if (typeof text !== 'string') return '';

            if (text.includes('[STICKER_START]')) {
        return '[AI表情包]';
    }

            // 优先匹配 [MESSAGE_START]...[MESSAGE_END] 格式，并提取中间的内容
            const messageMatch = text.match(/\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/);
            if (messageMatch && messageMatch[1]) {
                return messageMatch[1].trim(); // 返回指令中间的纯文本
            }

            // 如果是转账指令，显示为 "[转账]"
            if (text.includes('[TRANSFER_START]')) {
                return '[转账]';
            }

            // 如果是一起听邀请，显示为 "[一起听邀请]"
            if (text.includes('[MUSIC_SHARE]')) {
                return '[一起听邀请]';
            }

            // 如果没有匹配到任何特殊指令（例如用户自己发的消息），则原样返回
            return text;
        }
        /**
        * 功能：将消息添加到视图中
        * (根据用户提供的最新设计蓝图更新转账卡片样式)
        */
        function addMessageToView(message) {
                // 1. 安全检查：如果消息对象无效或没有文本内容，则直接退出，防止出错。
                if (!message || typeof message.text !== 'string') {
                    console.warn("尝试渲染一个无效的消息对象，已跳过:", message);
                    return;
                }

                // 2. 情况一：渲染系统消息 (例如：“对方已加入一起听”)
                if (message.type === 'system') {
                    const notification = document.createElement('div');
                    notification.className = 'system-notification';
                    notification.textContent = message.text;
                    chatMessagesContainer.appendChild(notification);
                    chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;
                    return; // 处理完毕，结束函数
                }

                // 3. 情况二：渲染表情包图片
                if (message.type === 'sticker' && message.url) {
                    // 创建通用的消息行、包装器和头像
                    const settings = currentOpenContact.avatarSettings || { show: true, radius: '50%' };
                    const row = document.createElement('div');
                    row.className = 'message-row';
                    // 这是新的代码
                    row.dataset.uuid = message.uuid;
                    if (message.uuid) { row.dataset.uuid = message.uuid; }

                    const wrapper = document.createElement('div');
                    wrapper.className = 'message-content-wrapper';

                    const avatar = document.createElement('img');
                    avatar.className = 'chat-avatar';
                    avatar.style.borderRadius = settings.radius;

                    if (message.sender === 'user') {
                        wrapper.classList.add('user');
                        avatar.src = currentOpenContact.user.avatar;
                    } else {
                        wrapper.classList.add('ai');
                        avatar.src = currentOpenContact.ai.avatar;
                    }

                    // 创建一个 <img> 元素来专门显示表情包
                    const stickerImage = document.createElement('img');
                    stickerImage.src = message.url;
                    stickerImage.className = 'chat-bubble sticker-bubble'; // 应用样式

                    wrapper.appendChild(avatar);
wrapper.appendChild(stickerImage);
row.appendChild(wrapper);
chatMessagesContainer.appendChild(row);

                    return; // 处理完毕，结束函数
                }

                // 4. 情况三与四：渲染普通文本气泡 或 转账卡片
                // 这两种都依赖于对 message.text 内容的解析，所以放在一起处理

                // 创建通用的消息行、包装器和头像
                const settings = currentOpenContact.avatarSettings || { show: true, radius: '50%' };
                const row = document.createElement('div');
                row.className = 'message-row';
                // 新增：创建左侧的选择器（圆形按钮）
const indicator = document.createElement('div');
indicator.className = 'selection-indicator';
row.appendChild(indicator);
                row.dataset.timestamp = message.timestamp.toString();
                if (message.uuid) { row.dataset.uuid = message.uuid; }

                const wrapper = document.createElement('div');
                wrapper.className = 'message-content-wrapper';

                const avatar = document.createElement('img');
                avatar.className = 'chat-avatar';
                avatar.style.borderRadius = settings.radius;

                if (message.sender === 'user') {
                    wrapper.classList.add('user');
                    avatar.src = currentOpenContact.user.avatar;
                } else {
                    wrapper.classList.add('ai');
                    avatar.src = currentOpenContact.ai.avatar;
                }

                // 使用正则表达式来判断是否为转账消息
                const transferRegex = /\[TRANSFER_START\]([\s\S]*?)-(\d*\.?\d+)\[TRANSFER_END\]/;
                const musicShareRegex = /\[MUSIC_SHARE\]/;
                const stickerRegex = /\[STICKER_START\]([\s\S]*?)\[STICKER_END\]/;

                const transferMatch = message.text.match(transferRegex);
                const stickerMatch = message.text.match(stickerRegex);

                let contentElement;// 用于承载气泡、卡片或图片的元素

                if (stickerMatch) {
                    // --- 情况一：匹配到AI发送的表情包 ---
                    const description = stickerMatch[1].trim();
                    const imageUrl = stickerMap.get(description); // 从字典查找URL

                    if (imageUrl) {
                        contentElement = document.createElement('img');
                        contentElement.src = imageUrl;
                        contentElement.className = 'chat-bubble sticker-bubble'; // 复用表情包样式
                    } else {
                        // 如果AI描述错误，找不到图片，则直接显示文字，方便调试
                        contentElement = document.createElement('div');
                        contentElement.className = 'chat-bubble ai-bubble';
                        contentElement.textContent = `[表情包指令错误: ${description}]`;
                    }

                } else if (transferMatch) {
                    // 情况三：如果匹配成功，渲染转账卡片
                    const remark = transferMatch[1].trim();
                    const amount = parseFloat(transferMatch[2]).toFixed(2);

                    contentElement = document.createElement('div');
                    // 以下是转账卡片的完整、未省略的HTML结构和内联样式，与你文件中其他部分保持一致
                    contentElement.style.cssText = "width: 200px; height: 100px; position: relative; background: white; overflow: hidden; border-radius: 24px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);";
                    contentElement.innerHTML = `
            <div style="left: 23px; top: 11px; position: absolute; color: black; font-size: 16px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">转账</div>
            <div style="left: 23px; top: 42px; position: absolute; color: #AFAFAF; font-size: 11px; font-family: sans-serif; font-weight: 400; word-wrap: break-word">${remark}</div>
            <div style="width: 130px; height: 22px; left: 20px; top: 64px; position: absolute; color: black; font-size: 20px; font-family: sans-serif; font-weight: 500; word-wrap: break-word">¥ ${amount}</div>
            <div style="width: 160px; height: 0px; left: 20px; top: 37px; position: absolute; border: 0.5px solid rgba(118, 118, 128, 0.12);"></div>
            <div style="width: 24px; height: 24px; left: 156px; top: 8px; position: absolute;">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M8.295 16.705L12.585 12.415L8.295 8.125C8.1067 7.9367 8.00091 7.6813 8.00091 7.415C8.00091 7.1487 8.1067 6.89331 8.295 6.705C8.48331 6.5167 8.7387 6.41091 9.005 6.41091C9.2713 6.41091 9.5267 6.5167 9.715 6.705L14.715 11.705C14.8087 11.798 14.8831 11.9086 14.9339 12.0304C14.9847 12.1523 15.0108 12.283 15.0108 12.415C15.0108 12.547 14.9847 12.6777 14.9339 12.7996C14.8831 12.9214 14.8087 13.032 14.715 13.125L9.715 18.125C9.62204 18.2187 9.50144 18.2931 9.36958 18.3439C9.23772 18.3947 9.09699 18.4208 8.955 18.4208C8.81301 18.4208 8.67228 18.3947 8.54042 18.3439C8.40856 18.2931 8.28796 18.2187 8.195 18.125C8.0067 17.9367 7.90091 17.6813 7.90091 17.415C7.90091 17.1487 8.0067 16.8933 8.195 16.705L8.295 16.705Z" fill="#363636"/>
                </svg>
            </div>
        `;


                } else if (musicShareRegex.test(message.text)) {
                    contentElement = document.createElement('div');
                    contentElement.className = 'listen-invite-card';
                    // 渲染通用的邀请卡片
                    contentElement.innerHTML = `
            <div style="width: 200px; height: 100px; position: relative; background: white; box-shadow: 0px 4px 6.099999904632568px rgba(0, 0, 0, 0.05); overflow: hidden; border-radius: 24px">
  <div style="left: 46px; top: 18px; position: absolute"><span style="color: black; font-size: 13px; font-family: Inter; font-weight: 400; word-wrap: break-word">邀请你加入 </span><span style="color: black; font-size: 13px; font-family: Inter; font-weight: 700; word-wrap: break-word">一起听</span></div>
  <div style="left: 18px; top: 46px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 400; word-wrap: break-word">我的耳机分你一半</div>
  <div style="width: 153px; height: 0px; left: 18px; top: 42px; position: absolute; outline: 1px var(--Miscellaneous-Button---Disabeld-BG, rgba(118, 118, 128, 0.12)) solid; outline-offset: -0.50px"></div>
  
  <svg width="16" height="19" viewBox="0 0 16 19" fill="none" xmlns="http://www.w3.org/2000/svg" style="position: absolute; left: 20px; top: 19px;"> 
    <path d="M4.63158 18.5263C7.18953 18.5263 9.26316 16.4527 9.26316 13.8947C9.26316 11.3368 7.18953 9.26315 4.63158 9.26315C2.07363 9.26315 0 11.3368 0 13.8947C0 16.4527 2.07363 18.5263 4.63158 18.5263Z" fill="black"/> 
    <rect x="6.73682" y="2.52631" width="2.52632" height="10.9474" fill="black"/> 
    <rect x="6.73682" width="9.26316" height="5.05263" rx="2" fill="black"/> 
  </svg>
  
  <div style="width: 321px; height: 226px; left: 63px; top: -170px; position: absolute; opacity: 0.08; background: #007AFF; box-shadow: 10px 10px 10px; border-radius: 9999px; filter: blur(5px)"></div>
  <div style="left: 83px; top: 79px; position: absolute; color: #BDBDBD; font-size: 10px; font-family: Inter; font-weight: 300; word-wrap: break-word">FROM MUSIC APP</div>
</div>
        `;
                } else {
                    // 情况四：如果以上都不是，就渲染普通的文本气泡
                    contentElement = document.createElement('div');
                    contentElement.className = 'chat-bubble';
                    if (message.sender === 'user') {
                        contentElement.classList.add('user-bubble');
                    } else {
                        contentElement.classList.add('ai-bubble');
                    }

                    let visibleText = message.text;
                    const messageRegex = /\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/;
                    const messageMatch = message.text.match(messageRegex);
                    if (messageMatch && messageMatch[1]) {
                        visibleText = messageMatch[1].trim();
                    }
                    contentElement.textContent = visibleText;
                }
                // 在所有 if/else if/else 块的外面，函数的末尾
                // 5. 统一将最终组装好的消息行添加到聊天界面
                wrapper.appendChild(avatar);
wrapper.appendChild(contentElement);

row.appendChild(wrapper);
chatMessagesContainer.appendChild(row);

                // 只有在非选择模式下才自动滚动
                if (!isMessageSelectionMode) {
                    chatMessagesContainer.scrollTo({ top: chatMessagesContainer.scrollHeight, behavior: 'smooth' });
                }

                return row;
            }
        // === 新增：“正在输入”提示的JS函数 ===

        /**
         * 功能：在聊天窗口显示一个“正在输入”的动画气泡
         */
        /**
        * 功能：在聊天窗口显示“正在输入”动画，并返回该动画的DOM元素
        * (已修改：移除重复检查，并返回元素本身)
        */
        function showTypingIndicator() {
            const row = document.createElement('div');
            row.className = 'message-row ai';
            // 给它一个class而不是ID，因为可能会有多个动画在排队
            row.classList.add('typing-indicator');

            const avatar = document.createElement('img');
            avatar.className = 'chat-avatar';
            avatar.src = currentOpenContact.ai.avatar;
            const avatarSettings = currentOpenContact.avatarSettings || { radius: '50%' };
            avatar.style.borderRadius = avatarSettings.radius;

            const bubble = document.createElement('div');
            bubble.className = 'chat-bubble ai-bubble';
            bubble.innerHTML = `
        <div class="typing-animation">
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
            <span class="typing-dot"></span>
        </div>
    `;

            row.appendChild(avatar);
            row.appendChild(bubble);
            chatMessagesContainer.appendChild(row);

            chatMessagesContainer.scrollTop = chatMessagesContainer.scrollHeight;

            // 关键：返回创建的行元素，以便之后替换它
            return row;
        }


        const moreFeaturesButton = document.getElementById('chat-add-attachment-button');
        const moreFeaturesPanel = document.getElementById('more-features-panel');
        const timePerceptionButton = document.getElementById('time-perception-feature');
        const receiptFeatureButton = document.getElementById('receipt-feature');
        const transferFeatureButton = document.getElementById('transfer-feature');
        const chatMessageInputForReceipt = document.getElementById('chat-message-input'); // 复用聊天输入框的ID


        // === 新增：转账功能所需元素 ===
        const transferModal = document.getElementById('transfer-modal');
        const transferModalCloseBtn = document.getElementById('transfer-modal-close-btn');
        const confirmTransferBtn = document.getElementById('confirm-transfer-btn');
        const transferAmountInput = document.getElementById('transfer-amount-input');
        const transferRemarkInput = document.getElementById('transfer-remark-input');


        // === 最终修复：同时兼容桌面鼠标和移动端触摸 ===
        function toggleFeaturesPanel(event) {
            // 阻止默认行为，如链接跳转或表单提交
            event.preventDefault();
            // 阻止事件冒泡，防止触发父元素的事件
            event.stopPropagation();
            // 切换面板的显示/隐藏
            moreFeaturesPanel.classList.toggle('active');
        }

        // 为同一个函数绑定两个事件
        moreFeaturesButton.addEventListener('click', toggleFeaturesPanel);
        moreFeaturesButton.addEventListener('touchend', toggleFeaturesPanel);

        // 3. 为“回执”功能按钮添加点击事件
        // === 更新：“回执”功能按钮的事件监听 ===

        receiptFeatureButton.addEventListener('click', () => {
            if (!currentOpenContact) {
                alert("请先打开一个对话！");
                return;
            }

            const instructionForAI = "现在轮到你了，请根据我们的历史对话，以及我刚刚发送的所有消息，以你的角色身份进行一次1到6条消息的回复。";
            // 新的调用方式：传入指令和当前的 contact 对象
            callAI(instructionForAI, currentOpenContact);

            moreFeaturesPanel.classList.remove('active');
        });

        // *** 在这里新增下面的代码 ***

        // === 最终正确版：用户向AI转账功能的事件监听 ===
        // === 最新版：用户向AI转账功能的事件监听（使用超简化格式） ===
        // === 更新：“转账”功能按钮，使其打开新弹窗 ===
        transferFeatureButton.addEventListener('click', () => {
            openTransferModal();
            // 点击后立即关闭“更多功能”面板
            moreFeaturesPanel.classList.remove('active');
        });

        // *** 新增代码结束 ***

        // 4. (可选但推荐) 添加一个全局点击事件，用于在点击面板外部区域时关闭面板
        document.addEventListener('click', (event) => {
            // 检查点击的不是面板本身，也不是触发按钮
            if (!moreFeaturesPanel.contains(event.target) && !moreFeaturesButton.contains(event.target)) {
                if (moreFeaturesPanel.classList.contains('active')) {
                    moreFeaturesPanel.classList.remove('active');
                }
            }
        });

        // --- 新增：消息选择和删除功能的核心JS逻辑 ---

        // 1. 全局变量
        let isMessageSelectionMode = false;
        let longPressTimer = null;
        const chatScreenContainer = document.getElementById('chat-screen');

        // 2. 获取新添加的顶栏按钮
        const normalHeaderActions = document.getElementById('chat-header-actions-normal');
        const selectHeaderActions = document.getElementById('chat-header-actions-select');
        const deleteMessagesBtn = document.getElementById('delete-messages-btn');
        const cancelSelectionBtn = document.getElementById('cancel-selection-btn');


        // 3. 定义功能函数
        function enterMessageSelectionMode(targetMessageRow) {
            if (isMessageSelectionMode) return;
            isMessageSelectionMode = true;
            chatScreenContainer.classList.add('selection-mode-active');

            // 切换顶栏按钮
            normalHeaderActions.style.display = 'none';
            selectHeaderActions.style.display = 'flex';

            // // 选中长按的那条消息
            // toggleMessageSelection(targetMessageRow);
        }

        function exitMessageSelectionMode() {
            isMessageSelectionMode = false;
            chatScreenContainer.classList.remove('selection-mode-active');

            // 切换回正常的顶栏按钮
            normalHeaderActions.style.display = 'flex';
            selectHeaderActions.style.display = 'none';

            // 取消所有消息的选中状态
            document.querySelectorAll('.message-row.selected').forEach(row => {
                row.classList.remove('selected');
            });
        }

        function toggleMessageSelection(messageRow) {
            if (!messageRow) return;
            messageRow.classList.toggle('selected');
        }

        // ===================================
        // 这是新的、简化的 deleteSelectedMessages
        // ===================================
        // ===================================
        // 这是【最终正确版】的 deleteSelectedMessages 函数
        // ===================================
        async function deleteSelectedMessages() {
            const selectedRows = document.querySelectorAll('.message-row.selected');
            if (selectedRows.length === 0 || !currentOpenContact) {
                return;
            }

            if (!confirm(`确定要永久删除选中的 ${selectedRows.length} 条消息吗？`)) {
                return;
            }

            // 1. 【核心修改】从UI收集待删除消息的 UUID
            const uuidsToDelete = new Set();
            selectedRows.forEach(row => {
                // 读取 dataset.uuid 而不是 timestamp
                if (row.dataset.uuid) {
                    uuidsToDelete.add(row.dataset.uuid);
                }
            });

            // 2. 【核心修改】直接在内存中的 history 上根据 UUID 进行过滤
            if (Array.isArray(currentOpenContact.history)) {
                currentOpenContact.history = currentOpenContact.history.filter(
                    // 检查 message.uuid 而不是 message.timestamp
                    message => !uuidsToDelete.has(message.uuid)
                );
            }

            // 3. 更新内存中的 lastMessage (这部分逻辑不变)
            if (currentOpenContact.history.length > 0) {
                const newLastMessageText = currentOpenContact.history[currentOpenContact.history.length - 1].text;
                currentOpenContact.lastMessage = cleanMessageForPreview(newLastMessageText);
            } else {
                currentOpenContact.lastMessage = "对话已清空";
            }

            // 4. 调用主保存函数来同步数据库
            await saveCurrentContactToDatabase();

            // 5. 更新UI
            selectedRows.forEach(row => row.remove());
            const contactItemInList = contactList.querySelector(`.contact-item[data-contact-id="${currentOpenContact.id}"]`);
            if (contactItemInList) {
                contactItemInList.querySelector('.contact-last-message').textContent = currentOpenContact.lastMessage;
            }

            // 6. 退出选择模式
            exitMessageSelectionMode();
            alert('删除成功！');
        }
        // ===================================
        // 这是【最终正确版】的事件监听代码块
        // ===================================

        // 1. 取消和删除按钮的点击事件
        cancelSelectionBtn.addEventListener('click', exitMessageSelectionMode);
        deleteMessagesBtn.addEventListener('click', deleteSelectedMessages);

        // 2. 定义统一的事件处理函数
        function handlePressStart(e) {
            if (isAiReplying) return;
            if (isMessageSelectionMode) return;
            const targetRow = e.target.closest('.message-row');
            if (!targetRow) return;

            clearTimeout(longPressTimer);

            longPressTimer = setTimeout(() => {
                enterMessageSelectionMode(targetRow);
            }, 500); // 长按超过500毫秒触发
        }

        function handlePressEnd() {
            clearTimeout(longPressTimer);
        }

        // 3. 【核心】为聊天容器绑定所有必需的鼠标和触摸事件
        chatMessagesContainer.addEventListener('mousedown', handlePressStart);
        chatMessagesContainer.addEventListener('touchstart', handlePressStart, { passive: true });

        chatMessagesContainer.addEventListener('mouseup', handlePressEnd);
        chatMessagesContainer.addEventListener('touchend', handlePressEnd);
        chatMessagesContainer.addEventListener('mouseleave', handlePressEnd); // 鼠标移出也要取消
        chatMessagesContainer.addEventListener('touchmove', handlePressEnd); // 手指滑动（滚动）时也要取消长按

        // 4. 聊天容器的单击事件
        chatMessagesContainer.addEventListener('click', (e) => {
            // 只有在选择模式下，单击才是为了切换选中状态
            if (isMessageSelectionMode) {
                const targetRow = e.target.closest('.message-row');
                // 阻止事件传播，防止触发其他可能存在的点击效果
                e.stopPropagation();
                e.preventDefault();
                toggleMessageSelection(targetRow);
            }
        });



        // *** 在这里新增下面的代码 ***

        // === 新增：世界书对话框的控制函数 ===
        // === 升级版：世界书对话框控制函数（支持新建和编辑） ===
        async function openWorldbookModal(bookId = null) {
            const modalTitle = addWorldbookModal.querySelector('h2');

            if (bookId) {
                // --- 编辑模式 ---
                currentEditingBookId = bookId; // 记录正在编辑的ID
                modalTitle.textContent = '编辑世界书';

                // 从数据库加载并填充内容
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                const book = existingData.value.find(b => b.id === bookId);
                if (book) {
                    worldbookNameInput.value = book.name;
                    worldbookContentInput.value = book.content;
                }
            } else {
                // --- 新建模式 ---
                currentEditingBookId = null; // 确保是null
                modalTitle.textContent = '新建世界书';
                // 清空输入框（虽然关闭时会清，但这里再清一次更保险）
                worldbookNameInput.value = '';
                worldbookContentInput.value = '';
            }

            // 显示弹窗
            addWorldbookModal.style.display = 'flex';
            setTimeout(() => {
                addWorldbookModal.style.opacity = '1';
                addWorldbookModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeWorldbookModal() {
            addWorldbookModal.style.opacity = '0';
            addWorldbookModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                addWorldbookModal.style.display = 'none';
                // 重置输入框内容
                worldbookNameInput.value = '';
                worldbookContentInput.value = '';
                currentEditingBookId = null;
            }, 300);
        }

        // --- 事件绑定 ---
        worldbookModalCloseBtn.addEventListener('click', closeWorldbookModal);

        // --- 保存世界书的逻辑 ---
        // === 升级版：保存世界书的逻辑（支持新建和编辑） ===
        saveWorldbookBtn.addEventListener('click', async () => {
            const name = worldbookNameInput.value.trim();
            const content = worldbookContentInput.value.trim();

            if (!name) {
                alert('世界书名称不能为空！');
                return;
            }

            try {
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                let books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];

                if (currentEditingBookId) {
                    // --- 编辑逻辑 ---
                    const bookIndex = books.findIndex(b => b.id === currentEditingBookId);
                    if (bookIndex > -1) {
                        books[bookIndex].name = name;
                        books[bookIndex].content = content;
                    }
                } else {
                    // --- 新建逻辑 ---
                    const newBook = {
                        id: Date.now(),
                        name: name,
                        content: content,
                        createdAt: new Date()
                    };
                    books.push(newBook);
                }

                // 将更新后的整个数组存回数据库
                await dbHelper.saveData('worldBooks', 'allWorldBooks', books);

                alert('世界书已保存！');
                closeWorldbookModal();
                loadAndRenderWorldBooks(); // 刷新列表以显示更改

            } catch (error) {
                console.error("保存世界书失败:", error);
                alert("保存失败，请查看控制台日志。");
            }
        });

        // *** 新增代码结束 ***

        // *** 在这里新增下面的代码 ***

        // === 新增：世界书渲染与加载函数 ===

        /**
         * 渲染世界书列表到界面上
         * @param {Array} books - 从数据库读取的世界书对象数组
         */
        function renderWorldBooks(books) {
            worldbookListContainer.innerHTML = ''; // 先清空列表
            if (!books || books.length === 0) {
                worldbookListContainer.innerHTML = '<p style="text-align:center; color:#888;">还没有创建任何世界书。</p>';
                return;
            }

            books.forEach(book => {
                const bookItem = document.createElement('div');
                bookItem.className = 'contact-item'; // 复用联系人列表项的样式
                bookItem.dataset.bookId = book.id;
                bookItem.innerHTML = `
            <input type="checkbox" class="contact-checkbox">
            <div class="contact-info">
                <div class="contact-name">${book.name}</div>
                <div class="contact-last-message" style="white-space: normal;">${book.content.substring(0, 50)}...</div>
            </div>
        `;
                worldbookListContainer.appendChild(bookItem);
            });
        }

        /**
         * 从数据库加载数据并调用渲染函数
         */
        async function loadAndRenderWorldBooks() {
            const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
            const books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];
            renderWorldBooks(books);
        }

        // *** 新增代码结束 ***

        // *** 在这里新增下面的代码 ***

        // === 新增：世界书多选删除逻辑 ===
        worldbookMultiselectBtn.addEventListener('click', () => {
            isWorldbookDeleteMode = !isWorldbookDeleteMode; // 切换模式
            worldbookListContainer.classList.toggle('delete-mode', isWorldbookDeleteMode);

            if (isWorldbookDeleteMode) {
                worldbookMultiselectBtn.textContent = '取消';
                addWorldbookBtn.textContent = '删除所选';
                addWorldbookBtn.classList.add('delete');
            } else {
                worldbookMultiselectBtn.textContent = '多选';
                addWorldbookBtn.textContent = '新建世界书';
                addWorldbookBtn.classList.remove('delete');
                // 退出时取消所有勾选
                worldbookListContainer.querySelectorAll('.contact-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // --- 修改“新建”按钮的行为，使其在删除模式下执行删除 ---
        addWorldbookBtn.addEventListener('click', () => {
            if (isWorldbookDeleteMode) {
                handleBatchDeleteWorldBooks();
            } else {
                openWorldbookModal();
            }
        });

        // --- 批量删除的执行函数 ---
        async function handleBatchDeleteWorldBooks() {
            const selectedCheckboxes = worldbookListContainer.querySelectorAll('.contact-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的世界书。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个世界书吗？此操作无法撤销。`)) {
                return;
            }

            const idsToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const bookId = cb.closest('.contact-item').dataset.bookId;
                idsToDelete.add(parseInt(bookId, 10));
            });

            try {
                const existingData = await dbHelper.loadData('worldBooks', 'allWorldBooks');
                let books = (existingData && Array.isArray(existingData.value)) ? existingData.value : [];

                // 过滤掉需要删除的书籍
                const updatedBooks = books.filter(book => !idsToDelete.has(book.id));

                // 将更新后的列表存回数据库
                await dbHelper.saveData('worldBooks', 'allWorldBooks', updatedBooks);

                // 重新加载列表并退出删除模式
                await loadAndRenderWorldBooks();
                worldbookMultiselectBtn.click(); // 模拟点击“取消”按钮

            } catch (error) {
                console.error("删除世界书失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        // *** 新增代码结束 ***

        // === 更新：转账功能，使其打开弹窗并发送正确格式的消息 ===
        function openTransferModal() {
            transferModal.style.display = 'flex';
            setTimeout(() => {
                transferModal.style.opacity = '1';
                transferModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeTransferModal() {
            transferModal.style.opacity = '0';
            transferModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                transferModal.style.display = 'none';
                transferAmountInput.value = '';
                transferRemarkInput.value = '';
            }, 300);
        }

        transferFeatureButton.addEventListener('click', () => {
            openTransferModal();
            moreFeaturesPanel.classList.remove('active');
        });

        timePerceptionButton.addEventListener('click', handleTimePerceptionToggle);

        transferModalCloseBtn.addEventListener('click', closeTransferModal);

        confirmTransferBtn.addEventListener('click', async () => {
            const amount = parseFloat(transferAmountInput.value);
            const remark = transferRemarkInput.value.trim();

            if (isNaN(amount) || amount <= 0) {
                alert("请输入有效的转账金额。");
                return;
            }
            if (!remark) {
                alert("备注不能为空。");
                return;
            }

            // 构造符合你 systemPrompt 要求的文本格式: 备注-金额
            const messageText = `[TRANSFER_START]${remark}-${amount}[TRANSFER_END]`;

            const userMessage = {
                sender: 'user',
                text: messageText,
                timestamp: new Date()
            };

            addMessageToView(userMessage);
            await saveMessageToHistory(userMessage, currentOpenContact.id);

            closeTransferModal();
        });

        /**
         * 最终确认版：处理AI回复的核心函数
         * 1. 严格恢复您最初设定的延迟时间计算公式。
         * 2. 包含所有已修正的错误和新增的功能。
         * @param {number} contactId - 对话的ID.
         * @param {Array} newMessages - AI返回的新消息对象数组.
         * @param {HTMLElement|null} initialIndicator - 为第一条消息预创建的“正在输入”动画元素.
         */
        async function updateChatViewWithAIResponse(contactId, newMessages, initialIndicator) {
            if (currentOpenContact && currentOpenContact.id === contactId) {
                let acceptedInvite = false;

                for (const [index, message] of newMessages.entries()) {

                    if (message.text.includes('[ACCEPT_INVITE]')) {
                        acceptedInvite = true;
                    }

                    let currentTypingIndicator;

                    if (index === 0 && initialIndicator) {
                        currentTypingIndicator = initialIndicator;
                    } else {
                        currentTypingIndicator = showTypingIndicator();
                    }

                    const messageRegex = /\[MESSAGE_START\]([\s\S]*?)\[MESSAGE_END\]/;
                    let visibleText = message.text.replace('[ACCEPT_INVITE]', '').trim();
                    const match = visibleText.match(messageRegex);
                    if (match && match[1]) {
                        visibleText = match[1].trim();
                    }

                    // --- 核心修正：严格恢复为您原来的延迟时间公式 ---
                    const typingDelay = Math.min(visibleText.length * 800 + 1000, 4000);

                    await new Promise(resolve => setTimeout(resolve, typingDelay));

                    currentTypingIndicator.remove();

                    if (visibleText) {
                        addMessageToView({ ...message, text: visibleText });
                    }
                }

                if (acceptedInvite && sharedListeningState.active === false) {
                    console.log(`AI "${currentOpenContact.ai.name}" 接受了邀请！`);

                    sharedListeningState.active = true;
                    sharedListeningState.contact = currentOpenContact;

                    const message = `${currentOpenContact.ai.name} 加入了一起听`;
                    // 确保调用了新的 showSystemNotification 函数
                    showSystemNotification(message, currentOpenContact.id);

                    if (dynamicIsland.classList.contains('expanded')) {
                        updateSharedListeningUI();
                    }
                }
            }
        }
        // === 备份与恢复功能的核心逻辑 ===

        // 定义我们数据库中所有的“表”名
        const objectStoreNames = ['settingsStore', 'messageContacts', 'musicPlaylists', 'worldBooks'];

        /**
         * 备份功能：读取所有数据并下载为JSON文件
         */
        async function backupData() {
            try {
                const fullBackup = {};
                for (const storeName of objectStoreNames) {
                    // 从每个“表”中读取所有数据
                    const data = await dbHelper.getAllDataFromStore(storeName);
                    fullBackup[storeName] = data;
                }

                // 将数据转换为JSON字符串
                const jsonString = JSON.stringify(fullBackup, null, 2);
                // 创建一个Blob对象
                const blob = new Blob([jsonString], { type: 'application/json' });
                // 创建一个下载链接
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');

                // 设置下载文件名，包含日期
                const date = new Date();
                const dateString = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                a.download = `phone_backup_${dateString}.json`;
                a.href = url;

                // 触发下载
                a.click();

                // 清理
                URL.revokeObjectURL(url);
                alert('备份文件已开始下载！');

            } catch (error) {
                console.error("备份失败:", error);
                alert(`备份失败: ${error.message}`);
            }
        }

        /**
         * 导入功能：读取JSON文件并覆盖现有数据
         */
        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            // 警告用户这是一个危险操作
            if (!confirm("警告：导入备份将覆盖所有当前数据，此操作不可撤销。您确定要继续吗？")) {
                // 清空文件输入，以便下次还能选择同一个文件
                importFileInput.value = '';
                return;
            }

            const reader = new FileReader();

            reader.onload = async (e) => {
                try {
                    const backupObject = JSON.parse(e.target.result);

                    // 恢复数据
                    for (const storeName of objectStoreNames) {
                        if (backupObject[storeName]) {
                            // 1. 清空旧数据
                            await dbHelper.clearStore(storeName);
                            // 2. 写入备份中的新数据
                            for (const record of backupObject[storeName]) {
                                // 我们的saveData需要id和value分开
                                await dbHelper.saveData(storeName, record.id, record.value);
                            }
                        }
                    }

                    alert("数据恢复成功！页面即将刷新以应用更改。");
                    // 刷新页面以加载新数据
                    location.reload();

                } catch (error) {
                    console.error("导入失败:", error);
                    alert(`导入失败: ${error.message}\n\n请确保您选择的是一个有效的备份文件。`);
                } finally {
                    importFileInput.value = '';
                }
            };

            reader.readAsText(file);
        }

        // 为按钮绑定事件
        backupDataBtn.addEventListener('click', backupData);
        importDataBtn.addEventListener('click', () => importFileInput.click()); // 点击“导入”按钮，实际是触发隐藏的文件选择框
        importFileInput.addEventListener('change', handleFileImport);

        // === 新增：歌单名称编辑功能 ===
        // === 最终修正版：歌单名称编辑功能 (采用重新渲染策略，确保状态同步) ===
        editPlaylistNameBtn.addEventListener('click', async () => {
            if (!currentOpenPlaylist) return;

            const newName = prompt("请输入新的歌单名称：", currentOpenPlaylist);

            if (newName === null || newName.trim() === "") return;

            const trimmedNewName = newName.trim();
            if (trimmedNewName === currentOpenPlaylist) return;

            try {
                // 1. 从数据库加载最新的完整歌单列表
                const allPlaylistsData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                if (!allPlaylistsData || typeof allPlaylistsData.value !== 'object') {
                    throw new Error("无法加载歌单数据库。");
                }
                let allPlaylists = allPlaylistsData.value;

                // 2. 检查新名称是否冲突
                if (allPlaylists[trimmedNewName]) {
                    alert("错误：该歌单名称已存在！");
                    return;
                }

                // 3. 在内存中执行重命名操作
                allPlaylists[trimmedNewName] = allPlaylists[currentOpenPlaylist];
                delete allPlaylists[currentOpenPlaylist];

                // 4. 将修改后的完整歌单列表，一次性存回数据库
                await dbHelper.saveData('musicPlaylists', 'allPlaylists', allPlaylists);

                // --- 5. 核心修复：不再手动修改UI，而是直接调用加载函数来重新渲染 ---
                await loadPlaylists(); // 这会根据最新的数据库数据，重新绘制整个歌单列表

                // 6. 更新详情页的标题和全局状态变量
                const titleElement = document.getElementById('playlist-name-title');
                if (titleElement) {
                    titleElement.textContent = trimmedNewName;
                }
                currentOpenPlaylist = trimmedNewName;

                alert("歌单名称已更新！");

            } catch (error) {
                console.error("编辑歌单名称失败:", error);
                alert(`编辑失败: ${error.message}`);
            }
        });

        // === 新增：歌单多选与删除的全部逻辑 ===

        // --- “多选”按钮的点击事件 ---
        playlistMultiselectBtn.addEventListener('click', () => {
            isPlaylistDeleteMode = !isPlaylistDeleteMode; // 切换模式
            playlistGrid.classList.toggle('delete-mode', isPlaylistDeleteMode);

            if (isPlaylistDeleteMode) {
                playlistMultiselectBtn.textContent = '取消';
                addPlaylistBtn.textContent = '删除所选';
                addPlaylistBtn.classList.add('delete');
            } else {
                playlistMultiselectBtn.textContent = '多选';
                addPlaylistBtn.textContent = '新建歌单';
                addPlaylistBtn.classList.remove('delete');
                // 退出时取消所有勾选
                playlistGrid.querySelectorAll('.playlist-checkbox').forEach(cb => cb.checked = false);
            }
        });

        // --- 修改“新建歌单”按钮的行为，使其在删除模式下执行删除 ---
        addPlaylistBtn.addEventListener('click', () => {
            if (isPlaylistDeleteMode) {
                // 如果是删除模式，则执行删除
                handleBatchDeletePlaylists();
            } else {
                // 否则，执行新建
                createNewPlaylist();
            }
        });
        // 将原有的新建逻辑封装成一个函数
        async function createNewPlaylist() {
            const playlistName = prompt("请输入新的歌单名称：");
            if (playlistName && playlistName.trim() !== "") {
                const newName = playlistName.trim();
                try {
                    const existingData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                    let playlists = (existingData && typeof existingData.value === 'object') ? existingData.value : {};
                    if (playlists[newName]) {
                        alert("歌单名称已存在！");
                        return;
                    }
                    playlists[newName] = { songs: [], coverUrl: null };
                    await dbHelper.saveData('musicPlaylists', 'allPlaylists', playlists);
                    createPlaylistCard(newName, playlists[newName]);
                } catch (error) {
                    console.error("保存歌单失败:", error);
                }
            }
        }

        // --- 批量删除的执行函数 ---
        async function handleBatchDeletePlaylists() {
            const selectedCheckboxes = playlistGrid.querySelectorAll('.playlist-checkbox:checked');
            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的歌单。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个歌单吗？此操作无法撤销。`)) {
                return;
            }

            const namesToDelete = new Set();
            selectedCheckboxes.forEach(cb => {
                const card = cb.closest('.playlist-card');
                namesToDelete.add(card.dataset.playlistName);
            });

            try {
                const existingData = await dbHelper.loadData('musicPlaylists', 'allPlaylists');
                let playlists = existingData.value;

                namesToDelete.forEach(name => {
                    delete playlists[name];
                });

                await dbHelper.saveData('musicPlaylists', 'allPlaylists', playlists);

                await loadPlaylists();
                playlistMultiselectBtn.click(); // 操作完成后自动退出多选模式

            } catch (error) {
                console.error("删除歌单失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        // === 新增：全局字体更换的全部逻辑 ===

        const defaultFontFamily = "sans-serif"; // 定义一个默认字体

        /**
         * 应用自定义字体或恢复默认字体的核心函数
         * @param {string | null} fontDataUrl - Base64格式的字体数据URL，或 null 以恢复默认
         */
        function applyCustomFont(fontDataUrl) {
            if (fontDataUrl) {
                // 如果有自定义字体数据，则创建 @font-face 规则并应用
                const fontFaceRule = `
            @font-face {
                font-family: 'CustomGlobalFont';
                src: url(${fontDataUrl});
            }
        `;
                customFontStyle.innerHTML = fontFaceRule;
                phoneFrame.style.fontFamily = "'CustomGlobalFont', " + defaultFontFamily;
            } else {
                // 如果没有数据，则清空规则并恢复默认字体
                customFontStyle.innerHTML = '';
                phoneFrame.style.fontFamily = defaultFontFamily;
            }
        }

        // --- 事件监听 ---

        // 1. 点击“更换字体”按钮
        changeFontBtn.addEventListener('click', () => {
            fontImportInput.click(); // 触发隐藏的文件选择框
        });

        // 2. 当用户选择了字体文件后
        fontImportInput.addEventListener('change', async (event) => {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = async (e) => {
                const fontDataUrl = e.target.result;
                try {
                    // a. 将字体数据保存到数据库
                    await dbHelper.saveData('settingsStore', 'customFont', fontDataUrl);
                    // b. 立即应用新字体
                    applyCustomFont(fontDataUrl);
                    alert('字体已成功应用！');
                } catch (error) {
                    console.error("保存或应用字体失败:", error);
                    alert("字体应用失败，请查看控制台。");
                }
            };
            // 将字体文件读取为Base64 Data URL
            reader.readAsDataURL(file);
            event.target.value = ''; // 清空输入，以便下次能选择同一个文件
        });

        // 3. 点击“恢复默认”按钮
        restoreFontBtn.addEventListener('click', async () => {
            if (confirm("确定要恢复为默认字体吗？")) {
                try {
                    // a. 从数据库删除自定义字体记录
                    await dbHelper.deleteData('settingsStore', 'customFont');
                    // b. 立即恢复默认字体
                    applyCustomFont(null);
                    alert('已恢复默认字体！');
                } catch (error) {
                    console.error("恢复默认字体失败:", error);
                    alert("恢复失败，请查看控制台。");
                }
            }
        });

        // === 新增：聊天记录搜索功能的全部逻辑 ===

        // 1. 获取新添加的HTML元素
        const chatSearchButton = document.getElementById('chat-search-button');
        const searchModal = document.getElementById('search-modal');
        const searchModalCloseBtn = document.getElementById('search-modal-close-btn');
        const searchInput = document.getElementById('search-input');
        const searchResultsContainer = document.getElementById('search-results-container');
        let searchDebounceTimer;

        // 2. 打开和关闭搜索对话框的函数
        function openSearchModal() {
            searchModal.style.display = 'flex';
            setTimeout(() => {
                searchModal.style.opacity = '1';
                searchModal.querySelector('.modal-content').style.transform = 'scale(1)';
                searchInput.focus(); // 自动聚焦到输入框
            }, 10);
        }

        function closeSearchModal() {
            searchModal.style.opacity = '0';
            searchModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                searchModal.style.display = 'none';
                searchInput.value = ''; // 清空输入
                searchResultsContainer.innerHTML = ''; // 清空结果
            }, 300);
        }

        // 3. 绑定打开/关闭事件
        chatSearchButton.addEventListener('click', openSearchModal);
        searchModalCloseBtn.addEventListener('click', closeSearchModal);


        /**
         * 【最终版】根据关键词创建居中、带省略号的消息摘要
         * (已集成移除换行符功能，确保单行显示)
         */
        /**
         * 【最终版 V2】根据关键词创建居中、带省略号的消息摘要
         * (截取长度已根据要求调整为3)
         */
        function createSnippet(fullText, keyword, contextLength = 3) { // <--- 核心修改在这里
            // 首先，移除原始文本中的所有换行符，将其替换为空格
            const cleanText = fullText.replace(/(\r\n|\n|\r)/gm, " ");

            const keywordIndex = cleanText.toLowerCase().indexOf(keyword.toLowerCase());

            if (keywordIndex === -1) {
                let snippet = cleanText.substring(0, contextLength * 2 + keyword.length);
                return snippet + '...';
            }

            const startIndex = Math.max(0, keywordIndex - contextLength);
            const endIndex = Math.min(cleanText.length, keywordIndex + keyword.length + contextLength);

            let snippet = cleanText.substring(startIndex, endIndex);

            if (startIndex > 0) {
                snippet = '...' + snippet;
            }

            if (endIndex < cleanText.length) {
                snippet = snippet + '...';
            }

            return snippet;
        }

        /**
         * 【最终版】渲染搜索结果的函数
         * (使用专属类名 chatsearch-content)
         */
        /**
        * 【最终版】渲染搜索结果的函数
        * (使用正确的两行式HTML结构，并包含 data-uuid)
        */
        function renderSearchResults(results, keyword, regex) {
            if (results.length === 0) {
                searchResultsContainer.innerHTML = '<p style="text-align:center; color:#888;">在此对话中未找到相关记录</p>';
                return;
            }

            searchResultsContainer.innerHTML = results.map(result => {
                const messageDate = new Date(result.message.timestamp);
                const formattedTime = `${String(messageDate.getMonth() + 1).padStart(2, '0')}-${String(messageDate.getDate()).padStart(2, '0')} ${String(messageDate.getHours()).padStart(2, '0')}:${String(messageDate.getMinutes()).padStart(2, '0')}`;

                const snippet = createSnippet(result.message.text, keyword);
                const highlightedSnippet = snippet.replace(regex, `<span class="highlight">$&</span>`);

                // 这个 return 语句会生成带有 data-uuid 的正确 HTML
                return `
            <div class="search-result-item" data-contact-id="${currentOpenContact.id}" data-uuid="${result.message.uuid}">
                <div class="result-header">
                    <div class="sender-name">${result.senderName}:</div>
                    <div class="time">${formattedTime}</div>
                </div>
                <div class="chatsearch-content">${highlightedSnippet}</div>
            </div>
        `;
            }).join('');
        }

        // 4. 核心：执行搜索并渲染结果
        // 替换为新版 performSearch 函数
        async function performSearch(keyword) {
            // 检查是否有关键词或当前联系人
            if (!keyword || keyword.length < 1 || !currentOpenContact) {
                searchResultsContainer.innerHTML = '';
                return;
            }

            // 搜索范围限定为当前联系人的 history
            const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];
            const results = [];

            // 在当前联系人历史记录中查找
            for (const message of history) {
                if (message.uuid && message.text.toLowerCase().includes(keyword.toLowerCase())) {
                    results.push({
                        message: message,
                        senderName: message.sender === 'user' ? currentOpenContact.user.name : currentOpenContact.ai.name
                    });
                }
            }

            // 将关键词和正则表达式一起传递给渲染函数
            const searchRegex = new RegExp(keyword.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'), 'gi');
            renderSearchResults(results, keyword, searchRegex);
        }


        // 5. 监听搜索框的输入事件 (使用防抖优化性能)
        searchInput.addEventListener('input', () => {
            clearTimeout(searchDebounceTimer);
            searchDebounceTimer = setTimeout(() => {
                performSearch(searchInput.value.trim());
            }, 300); // 停止输入300毫秒后执行搜索
        });

        // 6. 监听搜索结果的点击事件 (使用事件委托)
        searchResultsContainer.addEventListener('click', (event) => {
            const resultItem = event.target.closest('.search-result-item');
            if (resultItem) {
                // === 核心修复：这两行代码必须存在！ ===
                event.preventDefault();
                event.stopPropagation(); // 彻底阻止点击事件穿透

                const contactId = parseInt(resultItem.dataset.contactId, 10);
                const uuid = resultItem.dataset.uuid;

                if (contactId && uuid) {
                    closeSearchModal();
                    jumpToMessage(contactId, uuid); // 调用我们上面新的 jumpToMessage 函数
                }
            }
        });

        // 7. 核心：跳转到指定消息的函数
        // 用这个新版本，替换掉你原来的 jumpToMessage 函数
        async function jumpToMessage(contactId, uuid) {
            // 1. 先调用标准的 openChatView 函数，让它正确地构建聊天界面
            //    openChatView 会自动加载最新的30条消息
            await openChatView(contactId);

            // 2. 在页面打开后，我们再来处理跳转逻辑
            const history = Array.isArray(currentOpenContact.history) ? currentOpenContact.history : [];
            const targetMessageIndex = history.findIndex(msg => msg.uuid === uuid);

            // 3. 检查目标消息是否在已加载的30条内
            const isTargetVisible = chatMessagesContainer.querySelector(`.message-row[data-uuid="${uuid}"]`);

            // 4. 如果目标消息不在当前视图，说明是更早的消息，我们需要加载全部历史记录
            if (!isTargetVisible && targetMessageIndex !== -1) {
                console.log("目标消息不在初始视图，正在加载全部历史记录...");
                chatMessagesContainer.innerHTML = ''; // 清空当前仅30条的消息
                history.forEach(message => addMessageToView(message)); // 重新渲染所有消息
            }

            // 5. 现在可以安全地滚动到目标消息并高亮了
            setTimeout(() => {
                const targetMessage = chatMessagesContainer.querySelector(`.message-row[data-uuid="${uuid}"]`);
                if (targetMessage) {
                    targetMessage.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    targetMessage.classList.add('message-highlight');
                    setTimeout(() => {
                        targetMessage.classList.remove('message-highlight');
                    }, 1500);
                }
            }, 150); // 稍作延迟确保DOM渲染完成
        }
        /**
         * 【新增】处理时间感知功能开启/关闭的函数
         */
        async function handleTimePerceptionToggle() {
            if (!currentOpenContact) {
                alert("请先打开一个对话。");
                return;
            }

            // 检查当前状态 (如果属性不存在，则默认为false)
            const isEnabled = currentOpenContact.timePerceptionEnabled || false;

            const message = isEnabled ?
                "要关闭此AI的时间感知功能吗？关闭后它将不再知晓现实时间。" :
                "要为此AI开启感知现实时间的功能吗？开启后AI的回复会结合当前时间。";

            if (confirm(message)) {
                try {
                    // 切换状态
                    currentOpenContact.timePerceptionEnabled = !isEnabled;

                    // 使用“加载-修改-保存”模式安全地更新数据库
                    const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                    let allContacts = allContactsData.value || [];
                    const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                    if (contactIndex > -1) {
                        allContacts[contactIndex] = currentOpenContact;
                        await dbHelper.saveData('messageContacts', 'allContacts', allContacts);
                        alert(`时间感知功能已成功${currentOpenContact.timePerceptionEnabled ? '开启' : '关闭'}！`);
                    } else {
                        throw new Error("在数据库中找不到当前联系人。");
                    }

                } catch (error) {
                    console.error("更新时间感知状态失败:", error);
                    alert(`操作失败: ${error.message}`);
                } finally {
                    // 操作完成后关闭面板
                    moreFeaturesPanel.classList.remove('active');
                }
            }
        }

        // === 新增：邀请联系人功能的核心逻辑 ===

        // 1. 获取新添加的HTML元素
        const inviteContactBtn = document.getElementById('island-invite-button');
        const inviteModal = document.getElementById('invite-modal');
        const inviteModalCloseBtn = document.getElementById('invite-modal-close-btn');
        const inviteContactListContainer = document.getElementById('invite-contact-list-container');

        // 2. 打开和关闭对话框的函数
        function openInviteModal() {
            inviteModal.style.display = 'flex';
            // 动态加载并显示联系人列表
            loadAndDisplayContactsForInvite();
            setTimeout(() => {
                inviteModal.style.opacity = '1';
                inviteModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeInviteModal() {
            inviteModal.style.opacity = '0';
            inviteModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                inviteModal.style.display = 'none';
            }, 300);
        }

        // 3. 从数据库加载联系人并显示在对话框中的函数
        async function loadAndDisplayContactsForInvite() {
            // 清空旧列表，防止重复加载
            inviteContactListContainer.innerHTML = '<p style="text-align:center; color:#888;">正在加载联系人...</p>';

            try {
                const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                if (contactsData && Array.isArray(contactsData.value) && contactsData.value.length > 0) {
                    inviteContactListContainer.innerHTML = ''; // 加载成功后清空提示
                    contactsData.value.forEach(contact => {
                        const contactItem = document.createElement('div');
                        contactItem.className = 'invite-contact-item';

                        contactItem.innerHTML = `
                    <img src="${contact.ai.avatar}" alt="avatar" class="invite-contact-avatar">
                    <span class="invite-contact-name">${contact.ai.name}</span>
                    <button class="invite-button" data-contact-id="${contact.id}">邀请</button>
                `;

                        inviteContactListContainer.appendChild(contactItem);
                    });
                } else {
                    inviteContactListContainer.innerHTML = '<p style="text-align:center; color:#888;">你还没有任何联系人。</p>';
                }
            } catch (error) {
                console.error("加载联系人列表失败:", error);
                inviteContactListContainer.innerHTML = '<p style="text-align:center; color:red;">加载失败，请重试。</p>';
            }
        }

        // 4. 绑定事件监听器
        // 点击SVG图标，打开对话框
        inviteContactBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            openInviteModal();
        });

        // 点击关闭按钮或遮罩背景，关闭对话框
        inviteModalCloseBtn.addEventListener('click', closeInviteModal);
        inviteModal.addEventListener('click', (event) => {
            if (event.target === inviteModal) {
                closeInviteModal();
            }
        });

        // 使用事件委托来处理所有“邀请”按钮的点击事件
        // === 更新：处理“邀请”按钮点击事件，发送带歌曲信息的卡片 ===
        inviteContactListContainer.addEventListener('click', async (event) => {
            if (event.target.classList.contains('invite-button') && !event.target.disabled) {
                // 核心检查：确保当前有歌曲正在播放
                if (!playbackState.currentSong) {
                    alert("请先播放一首歌曲再邀请！");
                    return;
                }

                const button = event.target;
                const contactId = parseInt(button.dataset.contactId, 10);

                button.textContent = '已邀请';
                button.disabled = true;
                button.classList.add('invited');

                // 1. 从 playbackState 获取当前歌曲信息
                const songTitle = playbackState.currentSong.title;
                const artistName = playbackState.currentSong.artist;

                // 2. 构造你指定的 [MUSIC_SHARE] 消息文本
                const inviteMessageText = `[MUSIC_SHARE]对方邀请你收听-${songTitle}-${artistName}[MUSIC_SHARE]`;

                const userMessage = {
                    sender: 'user',
                    text: inviteMessageText,
                    timestamp: new Date()
                };

                try {
                    await saveMessageToHistory(userMessage, contactId);

                    if (currentOpenContact && currentOpenContact.id === contactId) {
                        addMessageToView(userMessage);
                    }

                    closeInviteModal();

                    const contactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                    const targetContact = contactsData.value.find(c => c.id === contactId);
                    if (targetContact) {
                        // This is the new, context-aware line
                        const songTitle = playbackState.currentSong.title;
                        await callAI(`(我给你分享了一起听的邀请，歌曲是《${songTitle}》，请根据我们的聊天记录和你的人设，自然地决定是否接受。`, targetContact);
                    }

                } catch (error) {
                    console.error("发送邀请卡片失败:", error);
                    alert("发送邀请失败，请查看控制台。");
                    button.textContent = '邀请';
                    button.disabled = false;
                    button.classList.remove('invited');
                }
            }
        });

        // === “一起听”功能最终修复版 (包含变量声明) ===

        // 1. 定义一个全局变量来管理“一起听”的状态 (这是缺失的部分)
        let sharedListeningState = {
            active: false,
            contact: null
        };

        // 2. 获取我们新添加的HTML头像容器
        const sharedAvatarsContainer = document.getElementById('shared-listening-avatars');
        const avatarImageContainer = document.getElementById('avatar-image-container');

        // 3. 编写一个函数，根据状态来更新UI
        // === 这是修正了UI更新逻辑的最终版本 ===
        function updateSharedListeningUI() {
            if (sharedListeningState.active && sharedListeningState.contact) {
                // 如果是激活状态，就获取对应的头像并显示
                const userAvatar = sharedListeningState.contact.user.avatar;
                const aiAvatar = sharedListeningState.contact.ai.avatar;

                // 关键修复：将头像插入到专用的图片容器中，而不是覆盖整个父容器
                avatarImageContainer.innerHTML = `
            <img src="${userAvatar}" class="shared-avatar-img" title="${sharedListeningState.contact.user.name}">
            <img src="${aiAvatar}" class="shared-avatar-img" title="${sharedListeningState.contact.ai.name}">
        `;
                // 父容器只负责控制整体的显示和隐藏
                sharedAvatarsContainer.classList.add('active');

            } else {
                // 否则，只清空图片容器并隐藏父容器
                avatarImageContainer.innerHTML = '';
                sharedAvatarsContainer.classList.remove('active');
            }
        }

        // 4. 定义一个函数，用于结束“一起听”状态
        function stopSharedListening() {
            sharedListeningState.active = false;
            sharedListeningState.contact = null;
            updateSharedListeningUI(); // 调用UI更新函数来隐藏头像
        }

        // === “一起听”功能最终交互逻辑 ===

        // 1. 获取新增的气泡和按钮元素
        const endSessionBubble = document.getElementById('end-session-bubble');
        const endListeningSessionBtn = document.getElementById('end-listening-session-btn');

        // 2. 为头像容器绑定新的点击事件，用于显示/隐藏气泡
        sharedAvatarsContainer.addEventListener('click', (event) => {
            // 确保只有在“一起听”模式激活时才响应
            if (sharedListeningState.active) {
                // 如果点击的不是“结束”按钮本身，则切换气泡的显示状态
                if (!event.target.closest('#end-listening-session-btn')) {
                    endSessionBubble.classList.toggle('active');
                }
            }
        });

        // 3. 为气泡内的“结束”按钮绑定点击事件
        endListeningSessionBtn.addEventListener('click', async (event) => {
            event.stopPropagation();
            endSessionBubble.classList.remove('active');

            try {
                // --- 关键的执行顺序在这里 ---

                // 步骤 1：先调用并“等待”系统提示函数完成。
                // 这个 await 关键字会强制程序在此暂停，直到消息被保存并且显示出来。
                // 这会确保“已经结束一起听”的灰色提示先出现在界面上。
                await showSystemNotification('已经结束一起听', sharedListeningState.contact.id);

                // 步骤 2：在系统提示显示完毕后，再调用并“等待”AI回应。
                // 只有在上面一行代码完全结束后，这一行才会开始执行。
                // AI的“...”输入气泡会在这里才出现。
                // This is the new, context-aware line
                await callAI("(我已经结束了一起听模式，我们继续聊吧)", sharedListeningState.contact);

            } catch (error) {
                // (可选) 如果在通知AI时出错，可以在控制台打印错误，方便排查问题
                console.error("在结束“一起听”并通知AI时发生错误:", error);
            } finally {
                // 步骤 3：无论上面的操作成功与否，最后都更新UI，隐藏头像。
                stopSharedListening();
            }
        });

        // 4. (可选但推荐) 添加一个全局点击事件，用于在点击页面其他地方时，自动隐藏气泡
        document.addEventListener('click', (event) => {
            // 如果气泡是显示的，并且点击的区域不在头像容器内
            if (endSessionBubble.classList.contains('active') && !sharedAvatarsContainer.contains(event.target)) {
                endSessionBubble.classList.remove('active');
            }
        }, true); // 使用捕获阶段确保它优先执行

        /**
         * 新增：在聊天界面显示一个系统级别的提示消息
         * @param {string} text - 要显示的提示文本
         */
        async function showSystemNotification(text, contactId) {
            if (!contactId) return;

            // 1. 构造一个带有 type: 'system' 的消息对象
            const systemMessage = {
                sender: 'system',
                type: 'system',
                text: text,
                timestamp: new Date()
            };

            // 2. 将这条系统消息永久保存到数据库
            await saveMessageToHistory(systemMessage, contactId);

            // 3. 如果用户正打开着这个对话，则立即在界面上显示出来
            if (currentOpenContact && currentOpenContact.id === contactId) {
                addMessageToView(systemMessage);
            }
        }



        // 2. 控制“添加表情”对话框显示和隐藏的函数
        function openAddEmojiModal() {

            const urlsTextarea = document.getElementById('emoji-urls-textarea');
            if (urlsTextarea) {
                urlsTextarea.value = '';
            }
            addEmojiModal.style.display = 'flex';
            setTimeout(() => {
                addEmojiModal.style.opacity = '1';
                addEmojiModal.querySelector('.modal-content').style.transform = 'scale(1)';
            }, 10);
        }

        function closeAddEmojiModal() {
            addEmojiModal.style.opacity = '0';
            addEmojiModal.querySelector('.modal-content').style.transform = 'scale(0.95)';
            setTimeout(() => {
                addEmojiModal.style.display = 'none';
                emojiUrlInput.value = ''; // 关闭时清空输入框
            }, 300);
        }

        // 3. 从数据库加载并渲染所有表情到网格中
        // 新版本：在渲染时加入了复选框
        async function loadAndRenderEmojis() {
            try {
                const emojis = await dbHelper.getAllDataFromStore('emojiStore');
                emojiGridContainer.innerHTML = '';
                if (emojis && emojis.length > 0) {
                    emojis.forEach(emoji => {
                        const container = document.createElement('div');
                        container.className = 'emoji-item-container';

                        // === 核心修改：在 HTML 结构中加入 input[type=checkbox] ===
                        container.innerHTML = `
                    <input type="checkbox" class="emoji-checkbox" value="${emoji.url}">
                    <img src="${emoji.url}" class="emoji-item" title="点击发送" data-url="${emoji.url}">
                    <p class="emoji-remark" contenteditable="true">${emoji.remark}</p>
                `;

                        // 为新创建的备注元素重新绑定"失去焦点"事件
                        const remarkElement = container.querySelector('.emoji-remark');
                        remarkElement.addEventListener('blur', async (event) => {
                            const newRemark = event.target.textContent.trim();
                            const urlToUpdate = container.querySelector('.emoji-item').dataset.url;

                            if (newRemark) {
                                try {
                                    await dbHelper.updateRecord('emojiStore', { url: urlToUpdate, remark: newRemark });
                                } catch (dbError) {
                                    console.error("更新备注失败:", dbError);
                                }
                            } else {
                                event.target.textContent = "点击修改备注";
                            }
                        });

                        emojiGridContainer.appendChild(container);
                    });
                } else {
                    emojiGridContainer.innerHTML = '<p style="color:#aaa; font-size:14px; text-align:center; grid-column: 1 / -1;">快来添加表情包包吧！</p>';
                }
            } catch (error) {
                console.error("加载表情失败:", error);
            }
        }

        // 4. “确认添加”按钮的点击处理函数
        // 用这个新版本替换旧的 handleSaveEmojis 函数
        // 用这个新版本替换旧的 handleSaveEmojis 函数
        async function handleSaveEmojis() {
            const urlsTextarea = document.getElementById('emoji-urls-textarea');
            const urlsText = urlsTextarea.value.trim();
            if (!urlsText) {
                alert('请输入图片URL！');
                return;
            }

            const urls = urlsText.split(',')
                .map(url => url.trim())
                .filter(url => url.startsWith('http'));

            if (urls.length === 0) {
                alert('未找到有效的URL。');
                return;
            }

            try {
                let successCount = 0;
                for (const url of urls) {
                    const newEmoji = {
                        url: url,
                        remark: "点击修改备注" // 提供一个默认备注
                    };
                    // 使用 updateRecord, 如果URL已存在则会覆盖，正好可以用来更新
                    await dbHelper.updateRecord('emojiStore', newEmoji);
                    successCount++;
                }

                alert(`成功添加/更新了 ${successCount} 个表情！`);
                closeAddEmojiModal();
                loadAndRenderEmojis(); // 重新加载

            } catch (error) {
                console.error("保存表情失败:", error);
                alert("添加失败，请检查URL格式。");
            }
        }

        // 5. 绑定所有事件监听器
        addEmojiBtn.addEventListener('click', () => {
            if (isEmojiDeleteMode) {
                handleBatchDeleteEmojis(); // 如果在删除模式，就执行删除
            } else {
                openAddEmojiModal(); // 否则，打开添加表情对话框
            }
        });
        emojiModalCloseBtn.addEventListener('click', closeAddEmojiModal);
        saveEmojiBtn.addEventListener('click', handleSaveEmojis);
        // 点击对话框外部的灰色区域也可以关闭
        addEmojiModal.addEventListener('click', (event) => {
            if (event.target === addEmojiModal) {
                closeAddEmojiModal();
            }
        });
        multiselectEmojiBtn.addEventListener('click', () => {
            isEmojiDeleteMode = !isEmojiDeleteMode; // 切换删除模式状态

            // 根据状态切换UI
            emojiGridContainer.classList.toggle('delete-mode', isEmojiDeleteMode);

            if (isEmojiDeleteMode) {
                // 进入删除模式
                multiselectEmojiBtn.textContent = '取消';
                addEmojiBtn.textContent = '删除所选';
            } else {
                // 退出删除模式
                multiselectEmojiBtn.textContent = '多选';
                addEmojiBtn.textContent = '添加';
                // 退出时，取消所有复选框的勾选
                emojiGridContainer.querySelectorAll('.emoji-checkbox').forEach(cb => cb.checked = false);
            }
        });
        async function handleBatchDeleteEmojis() {
            const selectedCheckboxes = emojiGridContainer.querySelectorAll('.emoji-checkbox:checked');

            if (selectedCheckboxes.length === 0) {
                alert('请至少选择一个要删除的表情。');
                return;
            }

            if (!confirm(`确定要删除选中的 ${selectedCheckboxes.length} 个表情吗？`)) {
                return;
            }

            try {
                let deletedCount = 0;
                // 遍历所有被选中的复选框
                for (const checkbox of selectedCheckboxes) {
                    const urlToDelete = checkbox.value; // 复选框的 value 就是图片的 URL
                    // 从 IndexedDB 中删除
                    await dbHelper.deleteData('emojiStore', urlToDelete);
                    deletedCount++;
                }

                alert(`成功删除了 ${deletedCount} 个表情！`);

                // 操作完成后，重新加载表情列表以刷新UI
                await loadAndRenderEmojis();

                // 主动“点击”取消按钮，退出删除模式
                multiselectEmojiBtn.click();

            } catch (error) {
                console.error("删除表情失败:", error);
                alert("删除失败，请查看控制台日志。");
            }
        }
        /**
         * 新增：主保存函数
         * 这是唯一一个负责将 currentOpenContact 的当前状态写入数据库的函数。
         * 任何需要保存的操作都应该调用它。
         */
        async function saveCurrentContactToDatabase() {
            if (!currentOpenContact) return;

            try {
                // 1. 从数据库加载最新的完整联系人列表
                const allContactsData = await dbHelper.loadData('messageContacts', 'allContacts');
                let allContacts = (allContactsData && Array.isArray(allContactsData.value)) ? allContactsData.value : [];

                // 2. 找到当前联系人在列表中的索引
                const contactIndex = allContacts.findIndex(c => c.id === currentOpenContact.id);

                if (contactIndex > -1) {
                    // 3. 用内存中最新的 currentOpenContact 对象，替换掉数组中的旧版本
                    allContacts[contactIndex] = currentOpenContact;
                } else {
                    // 如果在列表中找不到（例如，这是一个全新的对话），则添加到数组末尾
                    allContacts.push(currentOpenContact);
                }

                // 4. 将修改后的完整列表存回数据库
                await dbHelper.saveData('messageContacts', 'allContacts', allContacts);

            } catch (error) {
                console.error("Master save function failed:", error);
                // 在实际应用中，这里可能需要一个更友好的错误提示
            }
        }

            // === 新增：渲染图标设置列表的核心函数 ===
            async function renderIconSettings() {
                const container = document.getElementById('icon-list-container');
                if (!container) return;

                // 1. 获取主屏幕上所有带ID的App容器
                const appElements = document.querySelectorAll('#home-screen .app-container[id]');

                // 2. 从数据库加载已保存的自定义图标设置
                const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
                const savedIcons = (savedIconsData && savedIconsData.value) ? savedIconsData.value : {};

                container.innerHTML = ''; // 清空旧内容，防止重复

                // 3. 遍历每个App元素，生成对应的设置项
                appElements.forEach(app => {
                    const appId = app.id;
                    const appName = app.querySelector('.app-name').textContent;
                    const currentIconSrc = app.querySelector('.app-icon img').src;

                    // 获取为此App保存的URL，如果没有则为空字符串
                    const savedUrl = savedIcons[appId] || '';

                    const itemHTML = `
            <div class="icon-setting-item">
                <img src="${currentIconSrc}" class="icon-preview" data-app-id="${appId}">
                <div class="icon-details">
                    <span class="app-name-setting">${appName}</span>
                    <input type="text" class="icon-url-input" placeholder="输入新的图标URL" value="${savedUrl}" data-app-id="${appId}">
                </div>
            </div>
        `;
                    container.innerHTML += itemHTML;
                });
            }
// 监听整个列表容器的 'change' 事件 (当输入框失去焦点且内容改变时触发)
iconListContainer.addEventListener('change', async (event) => {
    // 检查事件是否由我们的URL输入框触发
    if (event.target.classList.contains('icon-url-input')) {
        const input = event.target;
        const appId = input.dataset.appId;
        const newUrl = input.value.trim();

        await updateAppIcon(appId, newUrl);
    }
});

// 负责更新UI和数据库的函数
async function updateAppIcon(appId, newUrl) {
    // 1. 更新主屏幕的图标
    const appIconOnHomeScreen = document.querySelector(`#${appId} .app-icon img`);
    // 2. 更新设置页的预览图标
    const iconPreviewInSettings = document.querySelector(`.icon-preview[data-app-id="${appId}"]`);

    if (!appIconOnHomeScreen || !iconPreviewInSettings) return;

    if (newUrl) {
        // 如果有新URL，则更新
        appIconOnHomeScreen.src = newUrl;
        iconPreviewInSettings.src = newUrl;
    } else {
        // 如果输入框被清空，则恢复为默认图标
        // 我们从HTML中读取默认值 (需要您确保img标签里有data-default-src属性)
        // 为了简单起见，我们这里先硬编码一个逻辑，更好的做法是在初始化时存储默认值
        // 这里我们重新加载页面来恢复默认值，更简单直接
        location.reload(); 
        return;
    }

    // 3. 保存到数据库
    try {
        const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
        let savedIcons = (savedIconsData && savedIconsData.value) ? savedIconsData.value : {};
        
        if (newUrl) {
            savedIcons[appId] = newUrl;
        } else {
            delete savedIcons[appId]; // 如果URL为空，则从保存记录中删除
        }

        await dbHelper.saveData('settingsStore', 'customAppIcons', savedIcons);
        
    } catch (error) {
        console.error("保存自定义图标失败:", error);
    }
}
// === 新增：页面加载时应用已保存的图标 ===
async function loadCustomIcons() {
    const savedIconsData = await dbHelper.loadData('settingsStore', 'customAppIcons');
    if (savedIconsData && savedIconsData.value) {
        const savedIcons = savedIconsData.value;
        for (const appId in savedIcons) {
            const iconUrl = savedIcons[appId];
            const appIconOnHomeScreen = document.querySelector(`#${appId} .app-icon img`);
            if (appIconOnHomeScreen && iconUrl) {
                appIconOnHomeScreen.src = iconUrl;
            }
        }
    }
}
// === 新增：时钟颜色更换的核心逻辑 ===

// 核心函数：更新所有时钟元素的颜色
function updateClockColor(color) {
    clockElements.forEach(span => {
        span.style.color = color;
    });
}

// 监听文本输入框的变化
clockColorInput.addEventListener('input', (event) => {
    const newColor = event.target.value;
    clockColorPicker.value = newColor; // 同步更新颜色选择器
    updateClockColor(newColor);
    dbHelper.saveData('settingsStore', 'clockColor', newColor); // 保存到数据库
});

// 监听颜色选择器的变化
clockColorPicker.addEventListener('input', (event) => {
    const newColor = event.target.value;
    clockColorInput.value = newColor; // 同步更新文本输入框
    updateClockColor(newColor);
    dbHelper.saveData('settingsStore', 'clockColor', newColor); // 保存到数据库
});
// === 新增：页面加载时应用已保存的时钟颜色 ===
async function loadClockColor() {
    const colorData = await dbHelper.loadData('settingsStore', 'clockColor');
    if (colorData && colorData.value) {
        const savedColor = colorData.value;
        updateClockColor(savedColor);
        // 同步更新设置页的输入框默认值
        clockColorInput.value = savedColor;
        clockColorPicker.value = savedColor;
    }
}
// === 新增：时钟高斯模糊功能的核心逻辑 ===

// 函数：根据传入的布尔值应用或移除模糊效果
function applyClockBlur(isEnabled) {
    if (isEnabled) {
        clockContainer.classList.add('clock-blur-enabled');
    } else {
        clockContainer.classList.remove('clock-blur-enabled');
    }
}

// 监听开关状态的变化
clockBlurToggle.addEventListener('change', async () => {
    const isEnabled = clockBlurToggle.checked;
    applyClockBlur(isEnabled); // 实时应用效果
    await dbHelper.saveData('settingsStore', 'clockBlurEffect', isEnabled); // 保存设置到数据库
});

// === 新增：页面加载时应用已保存的时钟模糊设置 ===
async function loadClockBlurSetting() {
    const blurData = await dbHelper.loadData('settingsStore', 'clockBlurEffect');
    // 如果数据库里有记录，则使用该记录的值；否则默认为 false (关闭)
    const isEnabled = blurData ? blurData.value : false;
    
    clockBlurToggle.checked = isEnabled; // 同步开关的状态
    applyClockBlur(isEnabled); // 应用效果
}

// --- 新增：快速回到底部按钮功能 ---

// 1. 获取需要的HTML元素
const scrollToBottomBtn = document.getElementById('scroll-to-bottom-btn');
// chatMessagesContainer 变量在之前的代码中已经获取，这里无需重复

// 2. 监听聊天窗口的滚动事件
chatMessagesContainer.addEventListener('scroll', () => {
    // 计算当前滚动条离底部的距离
    const scrollOffset = chatMessagesContainer.scrollHeight - chatMessagesContainer.scrollTop - chatMessagesContainer.clientHeight;
    
    // 设置一个阈值，比如滚动超过 300px 才显示按钮
    const threshold = 300; 

    if (scrollOffset > threshold) {
        // 如果离底部距离大于阈值，则显示按钮
        scrollToBottomBtn.classList.add('visible');
    } else {
        // 否则，隐藏按钮
        scrollToBottomBtn.classList.remove('visible');
    }
});

// 3. 监听按钮的点击事件
scrollToBottomBtn.addEventListener('click', () => {
    // 使用 smooth behavior 实现平滑滚动效果
    chatMessagesContainer.scrollTo({
        top: chatMessagesContainer.scrollHeight,
        behavior: 'smooth'
    });
});

// --- 新增（最终权威版）：点击(聚焦于)输入框时，自动滚动到聊天底部 ---

document.addEventListener('DOMContentLoaded', function() {
    
    const chatMessageInput = document.getElementById('chat-message-input');
    const chatContainer = document.getElementById('chat-messages-container');

    if (chatMessageInput && chatContainer) {
        
        // 检查浏览器是否支持 visualViewport API，这是处理虚拟键盘最现代、最可靠的方式
        if (window.visualViewport) {
            
            // 为 visualViewport 添加一个 'resize' 事件监听器
            window.visualViewport.addEventListener('resize', () => {
                // 这个事件会在键盘弹出或收起、导致可视区域变化时触发
                
                // 我们检查此时页面上获得焦点的元素是否就是我们的聊天输入框
                // 这样做可以避免在其他不相关的操作（如旋转屏幕）时也触发滚动
                if (document.activeElement === chatMessageInput) {
                    
                    // 如果是，我们就执行平滑滚动。
                    // 此时执行是100%准确的，因为我们是在浏览器完成布局调整后才操作的。
                    chatContainer.scrollTo({
                        top: chatContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }
            });

        } else {
            // 如果是不支持新API的老旧浏览器，我们保留一个基于延时的降级方案
            chatMessageInput.addEventListener('focus', () => {
                setTimeout(() => {
                    chatContainer.scrollTo({
                        top: chatContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                }, 300); // 使用一个更长的延迟作为后备方案
            });
        }
    }
});

    </script>

</body>

</html>
